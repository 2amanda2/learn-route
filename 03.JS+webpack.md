

## JS基础语法

### JavaScript介绍

#### 01JavaScript是什么

1. **是什么: **JavaScript是一种运行在客户端（浏览器）的编程语言，实现人机交互效果。
2. 作用（做什么？）
   1. 网页特效(监听用户的一些行为让网页做出对应的反馈)
   2. 表单验证（针对表单数据的合法性进行判断）
   3. 数据交互（获取后台的数据，渲染到前端）
   4. 服务端编程
3. 组成（有什么？）
   1. ECMAScript：规定了js语法的核心知识。比如变量、分支语句、循环语句、对象等
   2. Web APIs：
      1. DOM  操作文档，比如对页面元素进行移动、大小、添加删除等操作。
      2. 操作浏览器，比如页面弹框，检测窗口宽度，存储数据到浏览器等等

​	权威网站；MDN

​	JavaScript权威网站：https://developer.mozilla.org/zh-CN/docs/Web/JavaScript

​	![image-20241030210436505](C:\Users\12514\AppData\Roaming\Typora\typora-user-images\image-20241030210436505.png)

#### 02JavaScript书写位置

![image-20241030210534804](C:\Users\12514\AppData\Roaming\Typora\typora-user-images\image-20241030210534804.png)

##### 1.内部JavaScript

直接写在html文件里，用script标签包住；

**规范：**script标签写在</body>上面

拓展：alert（'你好，js'）页面弹出警告对话框

![image-20241030211416339](C:\Users\12514\AppData\Roaming\Typora\typora-user-images\image-20241030211416339.png)

##### 2.外部JavaScript

代码写在以js结尾的文件里

**语法：**通过script标签，引入到html页面中

![image-20241030211612789](C:\Users\12514\AppData\Roaming\Typora\typora-user-images\image-20241030211612789.png)

> [!CAUTION]
>
> 1.script标签中间无无需写代码，否则被忽略！
>
> 2.外部的JavaScript会使代码更有序，更易于服用，切没有了脚本的混合，html也会更加易读

##### 3.内联JavaScript

代码写在标签内部

**语法：**

注意：此处作为了解即可，vue框架会用这种模式

![image-20241030212126294](C:\Users\12514\AppData\Roaming\Typora\typora-user-images\image-20241030212126294.png)

#### 03JavaScript注释

目标：会使用两种Javascript注释方法

- 单行注释

  - 符号：//
  - 作用：//右边这一行的代码会被忽略
  - 快捷键：ctrl+/

- 块注释

  - 符号：/**/
  - 作用在/*和 */之间的所有内容都会被忽略
  - 快捷键：shift+alt+A

  

#### 04JavaSpript结束符

目标：了解JavaScript结束符

结束符

- 作用：使用英文的；代表语句结束
- 实际情况：实际开发中，可写可不写，浏览器（JavaScrpit）可以自动推断语句的结束位置
- 现状：在实际开发中，越来越多人主张，书写JavaScript代码时省略结束符
- **约定：为了风格统一，结束符要么每句都写，要么美剧都不写（按团队要求）**

#### 05输入和输出语法

​	输入和输出也可以理解为人和计算机的交互，用户通过键盘、鼠标等向计算机输入信息，计算机处理后再展示结果给用户，这便是一次输入和输出的过程。

1. #### 输出语法：

   1. 语法1：document.write('要出的内容')
      1. 作用：向body内输出内容
      2. 注意：如果输出的内容写的是标签，也会被解析成网页元素
   2. 语法2：alert('要出的内容')
      1. 作用：页面弹出警告框
   3. 语法3：console.log('控制台打印')

2. #### 输入语法:

   1. 语法：prompt('请输入您的姓名')
   2. 作用：显示一个对话框，对话框中包含一条文字信息，用来提示用户输入文字
   3. 展示：

![image-20241030214408919](C:\Users\12514\AppData\Roaming\Typora\typora-user-images\image-20241030214408919.png)

##### JavaScript代码执行顺序

- 按HTML文档流顺序执行JavaScript代码
- alert()和prompt()它们会跳过页面渲染先被执行

#### 06字面量

​	在计算机科学中，字面量（literal）用于在计算机中描述 事/物

​	比如：

- 我们的工资是10000，此时10000就是数字字面量
- '前端程序员'  字符串字面量
- 还有数组字面量[],以及对象字面量{}等等

### 变量

#### 01变量是什么

​	变量是计算机储存数据的“容器”

​	1.变量：

- 白话：变量就是一个装东西的盒子
- 通俗：变量是计算机用来存储数的“容器”，它可以让计算机变得有记忆。

![image-20241030220036064](C:\Users\12514\AppData\Roaming\Typora\typora-user-images\image-20241030220036064.png)

> [!CAUTION]
>
> 变量不是数据本身，它们仅仅是一个用于存储数值的容器，可以理解为是一个个用来装东西的纸箱子
>
> 例：HTML标签、教室、宿舍…

#### 02变量基本使用

##### 声明变量

要使用变量，首先需要创建变量（也称为声明变量或者定义变量）

语法：let 变量名

- 声明变量有两部分构成：声明关键词、变量名（标识）
- let即关键字，所谓关键字是系统提供的专门用来声明（定义）变量的词语

举例：let age

- 声明了一个age变量
- age即变量的名称，也叫标识符

##### 变量赋值

定义了一个变量后，需要对变量初始化（赋值）。变量名之后跟上一个"="，然后是数值。

![image-20241031101915826](C:\Users\12514\AppData\Roaming\Typora\typora-user-images\image-20241031101915826.png)

> [!CAUTION]
>
> 注意：是通过**变量名**来获得变量里面的数据

也可以声明变量的时候直接完成赋值操作，也称初始化。

![image-20241031102428264](C:\Users\12514\AppData\Roaming\Typora\typora-user-images\image-20241031102428264.png)

##### 变量变更

变量赋值后，还可以通过简单地给它一个不同的值来更新它

![image-20241031103303613](C:\Users\12514\AppData\Roaming\Typora\typora-user-images\image-20241031103303613.png)

> [!CAUTION]
>
> let不允许多次声明一个变量

##### 声明多个变量

语法：多个变量中间用逗号隔开

```js
let age = 18,uname = 'pink'
```

说明：看上去代码长度更短，单并**不推荐**。

#### 03变量的本质

内存：计算机中储存数据的地方，相当于一个空间

变量本质：是程序在内存中申请的一块用来存放数据的小空间

![image-20241031103941531](C:\Users\12514\AppData\Roaming\Typora\typora-user-images\image-20241031103941531.png)

#### 04变量命名规则与规范

规则：必须遵守，不遵守会报错（相当于法律层面）

规范：建议，不遵守不会报错，但不符合行业内通识（相当于道德层面）

1.规则：

- 不能用关键字
  - 关键字：有特殊含义的子图，JavaScript内置的ixie用于词汇。例如：let、var、if、for
- 只能用下划线、字母、数字、$组成，且数字不能开头
- 字母严格区分大小写，如Age和age是不同的变量

2.规范

- 起名要有意义
- 遵守小驼峰命名法
  - 第一个单词字母小写，后面每个单词字母大写。例：userName

#### 05变量拓展-数组

​	数组（Array）——一种将一组数据存储在单个变量名下的优雅方式

![image-20241102120859769](C:\Users\12514\AppData\Roaming\Typora\typora-user-images\image-20241102120859769.png)

##### 1.数组的基本使用

###### 1.声明语法

```js
let 数组名 = [数据1，数据2，…，数据n]

//例：
let names =['小明','小刚','小红','小丽','小木']
```

- 数组是按顺序保存，所以每个数据都有自己的编号
- 计算机中的编号从0开始，所以小明的编号是0，小刚的编号是1，以此类推。
- 在数组中，数据的编号也叫**索引**和**下标**
- 数组可以存储任意类型的数据

###### 2.取值语法

```js
数组名[下标]
//例：
let names = ['小明','小刚','小红','小丽','小米']
names[0]//小明
names[1]//小刚
```

- 通过下标取数据
- 取出来是什么类型，就根据这种类型特点来访问

###### 3.一些术语

- 元素：数组中保存的每个数据都叫数组元素
- 下标：数组中的数据的编号
- 长度：数组中数据的个数，通过数组的length属性获得

```js
let names = ['小明','小刚','小红','小丽','小米']
console.log(names[0])//小明
console.log(names[1])//小刚
console.log([names.length])//5
```

### **常量**

#### 常量的基本使用

- 概念：使用const声明的便两个成为“常量”
- 使用场景：当某个变量永远不会改变的时候，就可以使用const来声明，而不是let。
- 命名规范：和变量一致
- 常量使用：

![image-20241102122745262](C:\Users\12514\AppData\Roaming\Typora\typora-user-images\image-20241102122745262.png)

> [!WARNING]
>
> 注意：常量不允许重新赋值，声明的时候必须赋值（初始化）
>
> 小技巧：不需要重新赋值的数据使用const

### 数据类型

#### 数据类型分类

JS数据类型分为两大类：

- 1基本数据类型：
  - number 数字型
  - string 字符串型
  - boolean 布尔型
  - undefined 未定义型
  - null 空类型
- 2引用数据类型：
  - objoct 对象

#### 数据类型详解

##### 1.1数字（number）类型

JavaScript中的正数、负数、小数等统一称为数字型

> [!CAUTION]
>
> JS是弱数据类型，变量到底属于那种类型，只有等赋值之后才能确认
>
> Java是强数据类型  例如 int a = 3  必须是整数

**算术运算符**：主要包括加、减、乘、除、取余（求模）。

-  +：求和
-  -：求差
-  *：求积
-  /：求商
-  %：取模（取余数）
  -  开发中经常作为某个数字是否被整除

**算术运算符执行优先级顺序**

​	同时使用多个运算符编写程序时，会按着某种顺序先后执行，我们称为优先级。
JavaScript中 优先级越高越先被执行，优先级相同时以书从左向右执行。

- 乘、除、取余优先级相同
- 加、减优先级相同
- 乘、除、取余优先级大于加、减
- 使用 () 可以提升优先级
- 总结： 先乘除后加减，有括号先算括号里面的~~~

**NaN**代表一个计算错误。它是一个不正确的或者一个未定义的数学操作所得到的结果

```js
console.log('老师'-2)//NaN
```

**NaN** 是粘性的。任何对 NaN 的操作都会返回 NaN

```js
console.log(NaN+2)//NaN
```

##### 1.2字符串类型（string）

通过**单引号（ ''）** 、**双引号（ ""）**或**反引号( ` )** 包裹的数据都叫字符串，<u>单引号和双引号没有本质上的区别，推荐使用单引号。</u>

![image-20241102150642129](C:\Users\12514\AppData\Roaming\Typora\typora-user-images\image-20241102150642129.png)

> [!CAUTION]
>
> 1. 无论单引号或是双引号必须成对使用
> 2. <u>单引号/双引号可以互相嵌套，但是不以自已嵌套自已（口诀：外双内单，或者外单内双）</u>
> 3. **必要时可以使用转义符 \，输出单引号或双引号**

**字符串拼接**

场景： + 运算符 可以实现字符串的拼接。
口诀：数字相加，字符相连

![image-20241102150946980](C:\Users\12514\AppData\Roaming\Typora\typora-user-images\image-20241102150946980.png)

- 使用场景：

  -  拼接字符串和变量

  - 在没有它之前，要拼接变量比较麻烦

![image-20241102151045100](C:\Users\12514\AppData\Roaming\Typora\typora-user-images\image-20241102151045100.png)

- 语法：

  - `` (反引号)

  - 在英文输入模式下按键盘的tab键上方那个键（1左边那个键）

  - 内容拼接变量时，用 ${ } 包住变量

![image-20241102151143634](C:\Users\12514\AppData\Roaming\Typora\typora-user-images\image-20241102151143634.png)

##### 1.3布尔类型（boolean）

​	表示肯定或否定时在计算机中对应的是布尔类型数据。
​	它有两个固定的值 true 和 false，表示肯定的数据用 true（真），表示否定的数据用 false（假）。

![image-20241102151309341](C:\Users\12514\AppData\Roaming\Typora\typora-user-images\image-20241102151309341.png)

##### 1.4未定义类型（undefined）

未定义是比较特殊的类型，只有一个值 undefined

**什么情况出现未定义类型？**
只声明变量，不赋值的情况下，变量的默认值为 undefined，一般很少【直接】为某个变量赋值为 undefined。

![image-20241102151454270](C:\Users\12514\AppData\Roaming\Typora\typora-user-images\image-20241102151454270.png)

**工作中的使用场景：**
我们开发中经常声明一个变量，等待传送过来的数据。
如果我们不知道这个数据是否传递过来，此时我们可以通过检测这个变量是不是undefined，就判断用户是否有数据传递过来

#####  1.5null（空类型）

JavaScript 中的 null 仅仅是一个代表“无”、“空”或“值未知”的特殊值

![image-20241102151657174](C:\Users\12514\AppData\Roaming\Typora\typora-user-images\image-20241102151657174.png)

**null 和 undefined 区别：**

- undefined 表示没有赋值
- null 表示赋值了，但是内容为空

**null 开发中的使用场景：**
官方解释：把 null 作为尚未创建的对象
大白话： 将来有个变量里面存放的是一个对象，但是对象还没创建好，可以先给个null

### 检测数据类型

​	1.控制台输出语句和检测数据类型

![image-20241102152035699](C:\Users\12514\AppData\Roaming\Typora\typora-user-images\image-20241102152035699.png)

- 控制台语句经常用于测试结果来使用。
- 可以看出数字型和布尔型颜色为蓝色，字符串和undefined颜色为灰色

​	2.通过 typeof 关键字检测数据类型

​	typeof 运算符可以返回被检测的数据类型。它支持两种语法形式：

1. 作为运算符： **typeof x** （常用的写法）
2. 函数形式： **typeof(x)**

​	换言之，有括号和没有括号，得到的结果是一样的，所以我们直接使用运算符的写法。

![image-20241102152456507](C:\Users\12514\AppData\Roaming\Typora\typora-user-images\image-20241102152456507.png)

### 类型转换

#### <u>隐示转换</u>

某些运算符被执行时，系统内部自动将数据类型进行转换，这种转换称为隐式转换。
	**规则：**

- 号两边只要有一个是字符串，都会把另外一个转成字符串

-  除了+以外的算术运算符 比如 - * / 等都会把数据转成数字类型

​	**缺点：**

-  转换类型不明确，靠经验才能总结

​	**<u>小技巧：</u>**

-  +号作为正号解析可以转换成数字型
-  任何数据和字符串相加结果都是字符串

![image-20241102152800555](C:\Users\12514\AppData\Roaming\Typora\typora-user-images\image-20241102152800555.png)

#### 显示转换

​	编写程序时过度依靠系统内部的隐式转换是不严禁的，因为隐式转换规律并不清晰，大多是靠经验总结的规律。
​	为了避免因隐式转换带来的问题，通常根逻辑需要对数据进行显示转换。

**概念：**
自己写代码告诉系统该转成什么类型

**转换为数字型**

- Number(数据)
  - 转成数字类型
  - 如果字符串内容里有非数字，转换失败时结果为 NaN（Not a Number）即不是一个数字
  - NaN也是number类型的数据，代表非数字
- parseInt(数据)
  - 只保留整数
- parseFloat(数据)
  - 可以保留小数

**转换为字符串类型**

- String(数据)
- 变量.toString(进制)

### 流程控制

#### 运算符

##### 赋值运算符

- 赋值运算符：对变量进行赋值的运算符
  - 已经学过的赋值运算符：= 将等号右边的值赋予给左边, 要求左边必须是一个容器
  - 其他赋值运算符：
    - +=
    - -=
    - *=
    - /=
    - %=
- 使用这些运算符可以在对变量赋值时进行快速操作

![image-20241102153833980](C:\Users\12514\AppData\Roaming\Typora\typora-user-images\image-20241102153833980.png)

##### 一元运算符

众多的 JavaScript 的运算符可以根据所需表达式的个数，分为一元运算符、二元运算符、三元运算符

- 二元运算符，例：

  ```js
  let num = 10+20
  ```

- 一元运算符：

  - 例：正负号

- **自增：**
  -  符号：++
  -  作用：让变量的值 +1
- **自减：**
  -  符号：--
  -  作用：让变量的值 -1
- 使用场景：经常用于**<u>计数</u>**来使用。 比如进行10次操作，用它来计算进行了多少次了

![image-20241103134156424](C:\Users\12514\AppData\Roaming\Typora\typora-user-images\image-20241103134156424.png)

但是：

1. 前置自增和后置自增独立使用时二者并没有差别

2. 一般开发中都是独立使用

3. **<u>后面i++后置自增会使用相对较多，并且都是单独使用</u>**

   

#### 比较运算符

- 比较运算符：
  -  > ： 左边是否大于右边
  -  <： 左边是否小于右边
  -  >=： 左边是否大于或等于右边
  -  <=： 左边是否小于或等于右边
  -  ==： 左右两边值是否相等
  -  ===： 左右两边是否类型和值都相等
  -  !==： 左右两边是否不全等
  -  比较结果为boolean类型，即只会得到 true 或 false
- 对比
  - = 单等是赋值
  - == 是判断
  -  === 是全等
  - **<u>开发中判断是否相等，强烈推荐使用 ===</u>**



- 字符串比较，是比较的字符对应的ASCII码

  - 从左往右依次比较

  - 如果第一位一样再比较第二位，以此类推
  - 比较的少，了解即可

-  NaN不等于任何值，包括它本身

  - 涉及到"NaN“ 都是false

- 尽量不要比较小数，因为小数有精度问题

- 不同类型之间比较会发生隐式转换

  - 最终把数据隐式转换转成number类型再比较
  - 所以开发中，如果进行准确的比较我们更喜欢 === 或者 !==

![image-20241103140335681](C:\Users\12514\AppData\Roaming\Typora\typora-user-images\image-20241103140335681.png)

#### 逻辑运算符

| 符号 | 名称   | 日常读法 | 特点                           | 口诀           |
| ---- | ------ | -------- | ------------------------------ | -------------- |
| &&   | 逻辑与 | 并且     | 符号两边都为true，结果才为true | 一假则假       |
| \|\| | 逻辑或 | 或者     | 符号两边有一个true就为true     | 一真则真       |
| ！   | 逻辑非 | 取反     | true变false，false变true       | 假变真，真变假 |



#### 运算优先级

![image-20241103140837768](C:\Users\12514\AppData\Roaming\Typora\typora-user-images\image-20241103140837768.png)

### 语句

##### 表达式和语句的区别

- 表达式：是可以被求值的代码，JavaScript引擎会将其计算出一个结果
- 语句：是一段可以执行的代码。比如：prompt()可以弹出一个输入框，还有if语句 for循环语句等等

​	**区别:**

1. 因为表达式可被求值，所以它可以写在赋值语句的右侧。
2. 而语句不一定有值，所以比如 alert() for和break 等语句就
   不能被用于赋值。

##### 程序三大流程控制语句

- 顺序结构
- 分支结构
- 循环结构

![image-20241103142324912](C:\Users\12514\AppData\Roaming\Typora\typora-user-images\image-20241103142324912.png)

###### 分支语句

​	分支语句包含：If分支语句、三元运算符、switch语句

**if语句**

- if语句有三种使用：单分支、双分支、多分支

- 单分支使用语法

  ![image-20241103142656243](C:\Users\12514\AppData\Roaming\Typora\typora-user-images\image-20241103142656243.png)

- 双分支if语法

  ![image-20241103142718328](C:\Users\12514\AppData\Roaming\Typora\typora-user-images\image-20241103142718328.png)

- 多分支if语法

  ![image-20241103142843997](C:\Users\12514\AppData\Roaming\Typora\typora-user-images\image-20241103142843997.png)

**三元运算符**

- 使用场景：其实是和if双分支更简单的写法，可以使用三元表达式

- 符号：？与：配合使用

- 语法：

  ![image-20241103143019516](C:\Users\12514\AppData\Roaming\Typora\typora-user-images\image-20241103143019516.png)

- 一般用来取值

**switch语句**

![image-20241103143053842](C:\Users\12514\AppData\Roaming\Typora\typora-user-images\image-20241103143053842.png)

###### 循环结构

​	**断点调试**

- 作用：学习时可以帮助更好的理解代码运行，工作时可以更快找到bug
- 浏览器打开调试界面
  1. 按F12打开开发者工具
  2. 点到sources一栏
  3. 选择代码文件
- 断点：在某句代码上加的标记就叫断点，当程序执行到这句有标记的代码时会暂停下来

![image-20241103143237633](C:\Users\12514\AppData\Roaming\Typora\typora-user-images\image-20241103143237633.png)

**while循环基本语法**

```js
while (循环条件) {
    要重复执行的代码(循环体)
}

```

释义：

- 跟if语句很像，都要满足小括号里的条件为true才会进入 循环体 执行代码

- while大括号里代码执行完毕后不会跳出，而是继续回到小括号里判断条件是否满足，若满足又执行大括号里的代码，然后再回到小括号判断条件，直到括号内条件不满足，即跳出

**while循环三要素**

![image-20241103143535444](C:\Users\12514\AppData\Roaming\Typora\typora-user-images\image-20241103143535444.png)



**循环退出**

**循环结束：**

- break：退出循环
- continue：结束本次循环，继续下次循环

**区别：**

- continue 退出本次循环，一般用于排除或者跳过某一个选项的时候, 可以使用continue
- break 退出整个循环，一般用于结果已经得到, 后续的循环不需要的时候可以使用

### 数组

#### for循环

##### for循环基本使用

###### 1.for循环语法

**作用：**重复执行代码

**好处：**把声明起始值、循环条件、变化值写到一起，让人一目了然，它是最常使用的循环形式

![image-20241103144418742](C:\Users\12514\AppData\Roaming\Typora\typora-user-images\image-20241103144418742.png)

###### 2.退出循环

- continue 退出本次循环，一般用于排除或者跳过某一个选项的时候, 可以使用continue
- break 退出整个for循环，一般用于结果已经得到, 后续的循环不需要的时候可以使用

了解：
1. while(true) 来构造“无限”循环，需要使用break退出循环。
2. for(;;) 也可以来构造“无限”循环，同样需要使用break退出循环。

##### 3.for循环嵌套

![image-20241103144740530](C:\Users\12514\AppData\Roaming\Typora\typora-user-images\image-20241103144740530.png)

#### 数组

##### 数组基本使用

###### 遍历数组（重点）

- 用循环把数组中的每个元素都访问到，一般会用for循环遍历

![image-20241103145415072](C:\Users\12514\AppData\Roaming\Typora\typora-user-images\image-20241103145415072.png)

###### 操作数组

![image-20241103145523374](C:\Users\12514\AppData\Roaming\Typora\typora-user-images\image-20241103145523374.png)

操作数组-新增

- **数组.push()**方法将一个或多个元素添加到数组的**<u>末尾</u>**，并返回该数组的新长度（<u>重点</u>）

![image-20241103172310122](C:\Users\12514\AppData\Roaming\Typora\typora-user-images\image-20241103172310122.png)

- arr.unshift(新增的内容) 方法将一个或多个元素添加到数组的**开头**，并返回该数组的新长度

![image-20241103172515706](C:\Users\12514\AppData\Roaming\Typora\typora-user-images\image-20241103172515706.png)

###### 数组操作-删除

- 数组. pop() 方法从数组中删除**最后一个元素**，并返回该元素的值

![image-20241103173550000](C:\Users\12514\AppData\Roaming\Typora\typora-user-images\image-20241103173550000.png)

- 数组.shift() 方法从数组中删除**第一个元素**，并返回该元素的值

![image-20241103172949123](C:\Users\12514\AppData\Roaming\Typora\typora-user-images\image-20241103172949123.png)

- 需求使用场景：

1. 随机抽奖，中奖的用户就需要从数组里面删除，不允许重复抽奖
2. 点击删除按钮，相关的数据会从商品数据中删除

- **数组. splice()** 方法 删除指定元素

![image-20241103173311218](C:\Users\12514\AppData\Roaming\Typora\typora-user-images\image-20241103173311218.png)

###### 数组排序

- 数组.sort()方法可以排序

![image-20241103173853971](C:\Users\12514\AppData\Roaming\Typora\typora-user-images\image-20241103173853971.png)

### 函数

#### 函数使用

##### 1.函数声明

- 函数的声明语法

```js
function 函数名(){
    函数体
}
```

- 例

```js
function sayHi(){
    document.write('hai~~')
}
```

##### 2.函数使用

- 函数名命名规范
  - 和变量命名基本一致
  - 尽量小驼峰式命名法
  - 前缀应该为动词
  - 命名建议：常用动词约定

![image-20241103175338464](C:\Users\12514\AppData\Roaming\Typora\typora-user-images\image-20241103175338464.png)

##### 3.函数调用

- 函数调用语法

```js
//函数调用，这些函数体内的代码逻辑会被执行
函数名()
```

> [!CAUTION]
>
> 注意：声明（定义）的函数必须调用才会正真被执行，使用()调用函数

例：

```js
//函数一次声明可以多次调用，每一次函数调用函数体里面的代码会重新执行一次
sayHi()
sayHi()
```

> [!NOTE]
>
> alert() , parseInt() 这种名字后面跟小括号的本质都是函数的调用

##### 4.函数体

​	函数体是函数的构成部分，它负责将相同或相似代码“包裹”起来，直到函数调用时函数体内的代码才会被执行。函数的功能代码都要写在函数体当中。

![image-20241103192730477](C:\Users\12514\AppData\Roaming\Typora\typora-user-images\image-20241103192730477.png)

#### 函数传参

- 声明语法

```js
function 函数名(参数列表){
    函数体
}
```

**参数列表**

- 传入数据列表
- 声明这个函数需要穿入几个数据
- 多个数据用逗号隔开

例：

- 单个参数

```js
function getSquare(num1){
    document.write(num1*num1)
}
```

- 多个参数

```js
function getSum(num1,num2){
    document.write(num1+num2)
}
```

**调用语法**

```js
函数名(传递的参数列表)
//例：
getSquare(8)
getSquare(10,20)
```

- 调用函数时，需要传入几个数据就写几个，用逗号隔开

![image-20241103194752281](C:\Users\12514\AppData\Roaming\Typora\typora-user-images\image-20241103194752281.png)





![image-20241103194858071](C:\Users\12514\AppData\Roaming\Typora\typora-user-images\image-20241103194858071.png)

- 形参：声明函数时写在函数名右边小括号里的叫形参（形式上的参数）

-  实参：调用函数时写在函数名右边小括号里的叫实参（实际上的参数）
-  形参可以理解为是在这个函数内声明的变量（比如 num1 = 10）实参可以理解为是给这个变量赋值
-  开发中尽量保持形参和实参个数一致
-  我们曾经使用过的 alert('打印'), parseInt('11'), Number('11') 本质上都是函数调用的传参

**参数默认值**

```js
function getSum(x=0,y=0){
    document.write(x+y)
}
getSum()//结果是0，而不是N
getSum(1,2)//结果是3
```

#### 函数返回值

- 当函数需要返回数据出去时，用return关键字
- 语法

```
return 数据      return 20
```

![image-20241103201339976](C:\Users\12514\AppData\Roaming\Typora\typora-user-images\image-20241103201339976.png)

- 细节
  - 在函数体中使用return关键字能将内部的执行结果交给函数外部使用
  - return后面代码不会再被执行，会立即结束当前函数，所以return后面的数据不要换行写
  - return函数可以没有return，这种情况函数默认返回值为undefined

#### 作用域

​	通常来说，一段程序代码中所用到的名字并不总是有效和可用的，而限定这个名字的可用性的代码范围就是这个名
字的**作用域。**
​	作用域的使用提高了程序逻辑的局部性，增强了程序的可靠性，减少了名字冲突。

![image-20241103202018270](C:\Users\12514\AppData\Roaming\Typora\typora-user-images\image-20241103202018270.png)

在JavaScript中，根据作用域的不同，变量可以分为：

**全局变量：**全局变量在任何区域都可以访问和修改

**局部变量：**局部变量只能在当前函数内部访问和修改

> [!NOTE]
>
> 变量有一个坑， 特殊情况：
> 1.如果函数内部，变量没有声明，直接赋值，也当全局变量看，但是强烈不推荐
> 2.但是有一种情况，函数内部的形参可以看做是局部变量。

##### 变量的访问原则（<u>就近原则</u>）

- 只要是代码，就至少有一个作用域
- 写在函数内不的局部作用域
- 如果函数中还有函数，那么在这个作用域中有可以诞生一个作用域
- **访问原则：<u>在能够访问到的情况下 先局部，局部没有再找全局</u>**

### 匿名函数

​	函数可以分为：具名函数和匿名函数

​	**具名函数：**

​		声明：function fn(){}

​		调用fn()

​	**匿名函数：**

​		function(){}

匿名函数：没有名字的函数，无法直接使用。

​	**使用方式：**

- 函数表达式
- 立即执行函数

###### 1.函数表达式

​	将匿名函数赋值给一个变量，并且通过变量名称进行调用 我们将这个称为这个**函数表达式**。

- 语法

```js
let fn = function(){
    //调用体
}
```

- 调用

```js
fn() //函数名()
```

###### 2.立即执行函数

​	场景介绍：避免全局变量之间的污染

​	**语法：**

```js
//方式1
(function(){console.log(11)})();
//方式2
(function(){console.log(11)})();
//不需要调用，立即执行
```

> [!WARNING]
>
> 注意：多个立即执行函数要用；隔开，要不然会报错

##### 逻辑中断

​	开发中，还会遇到以下写法：

![image-20241103210246135](C:\Users\12514\AppData\Roaming\Typora\typora-user-images\image-20241103210246135.png)

###### 1.逻辑运算符里的短路

- 短路：只存在于&&和||中，当满足一定条件会让右边代码不执行

  | 符号 | 短路条件          |
  | ---- | ----------------- |
  | &&   | 左边为false就短路 |
  | \|\| | 左边为true就短路  |

- 原因：通过左边能得到整个式子的结果，一次没必要再判断右边
- 运算结果：无论&&还是||，运算结果都是最后被执行的表达式值，一般用在变量赋值

###### 2.转为boolean

​	**显示转换：**

​	1.boolean（内容）

**记忆："、0、undefined、null、false、NaN转换为布尔值后都是false，其余则为true**

![image-20241103211053582](C:\Users\12514\AppData\Roaming\Typora\typora-user-images\image-20241103211053582.png)

​	2.隐式转换

1. 有字符串的加法 “” + 1 ，结果是 “1”
2. 减法 - （像大多数数学运算一样）只能用于数字，它会使空字符串 "" 转换为 0
3. null 经过数字转换之后会变为 0
4. undefined 经过数字转换之后会变为 NaN

![image-20241103211510365](C:\Users\12514\AppData\Roaming\Typora\typora-user-images\image-20241103211510365.png)

### 对象

#### 1.对象是什么

	对象（object）：JavaScript里的一种数据类型
- 可以理解为是一种无序的数据集合， 注意数组是有序的数据集合
- 用来描述某个事物，例如描述一个人
  - 人有姓名、年龄、性别等信息、还有吃饭睡觉打代码等功能
  - 如果用多个变量保存则比较散，用对象比较统一
- 比如描述 班主任 信息：
  - 静态特征 (姓名, 年龄, 身高, 性别, 爱好) => 可以使用数字, 字符串, 数组, 布尔类型等表示
  - 动态行为 (点名, 唱, 跳, rap) => 使用函数表示

#### 2.对象使用

##### 1.对象声明语法

![image-20241103212724001](C:\Users\12514\AppData\Roaming\Typora\typora-user-images\image-20241103212724001.png)

例如：

![image-20241103212737545](C:\Users\12514\AppData\Roaming\Typora\typora-user-images\image-20241103212737545.png)

**实际开发中，多用花括号。<u>{}是对象字面量</u>**

##### 2.对象有属性和方法组成

- 属性：信息或叫特征（名词）。比如 手机尺寸、颜色、重量
- 方法：功能或叫行为（动词）。比如 手机打电话、发短信、玩游戏

![image-20241103214555080](C:\Users\12514\AppData\Roaming\Typora\typora-user-images\image-20241103214555080.png)

##### 3.属性

- 数据描述性的信息称为属性，如人的姓名、身高、年龄、性别等，一般是名词性的。

![image-20241103214813196](C:\Users\12514\AppData\Roaming\Typora\typora-user-images\image-20241103214813196.png)

- 属性都是成 对出现的，包括属性名和值，它们之间使用英文 : 分隔
- 多个属性之间使用英文 , 分隔
- 属性就是依附在对象上的变量（外面是变量，对象内是属性）
-  属性名可以使用 "" 或 ''，一般情况下省略，除非名称遇到特殊符号如空格、中横线等



对象的本质式无语的数据集合，操作数据无非就是**增、删、改、查** 语法：

![image-20241103220119469](C:\Users\12514\AppData\Roaming\Typora\typora-user-images\image-20241103220119469.png)

###### 3.1.属性-查

- 声明对象，并添加了若干属性后，可以使用，获得对象中属性对应的值，称之为属性访问
- 语法：对象名.属性  。也叫点形式
- 简单理解就是获得对象里面的属性值

```js
let peson = {
    uname:'p老师'，
    age:18,
    gender:'女'
}
console.log(person.uname)
console.log(person.age)
console.log(person.gender)
```

3.2.属性-改

- 语法：对象.属性名 = 新值

```js
let person{
    uname:'p老师',
    age:18,
    gender:'女'
}
person.gender ='男'
console.log(person.gender)//修改了为男
console.log(person)
```

###### 3.3.属性-增

- 语法：对象名.新属性 = 新值

![image-20241103221622589](C:\Users\12514\AppData\Roaming\Typora\typora-user-images\image-20241103221622589.png)

###### 3.4.属性-删（了解）

- 语法：delet 对象名.属性

![image-20241103221722451](C:\Users\12514\AppData\Roaming\Typora\typora-user-images\image-20241103221722451.png)

> [!NOTE]
>
> 改和增语法一样，判断标准就是对象有没有这个属性，**没有就是新增，有就是改**



###### 3.5.属性-查的另一种写法

- 对于多次属性或-等属性，点操作就不能用了
- 可以采取：对象['属性'] 方式，|单双引号都可以。 也叫[]形式

![image-20241104091907894](C:\Users\12514\AppData\Roaming\Typora\typora-user-images\image-20241104091907894.png)

- 也可以用于其他正常属性，比如；
- []语法里面的值如果不添加引号 默认会当成变量解析

![image-20241104093333157](C:\Users\12514\AppData\Roaming\Typora\typora-user-images\image-20241104093333157.png)

总结：
	没有必要的时候直接使用点语法，在需要解析变量的时候使用[]语法





##### 对象中的方法

- 数据行为性的信息称为方法，比如跑步、唱歌等，一般式动词性的，其本质是函数。

![image-20241104093531878](C:\Users\12514\AppData\Roaming\Typora\typora-user-images\image-20241104093531878.png)

1. 方法是由方法名和函数梁部分构成，它们之间使用：分隔
2. 多个属性之间使用英文,隔开
3. 方法是依附在对象的函数
4. 方法名可以使用""或'',一般情况下省略，除非名称遇上特殊符号如空格、中横线等



- 声明对象，并添加了若干方法后，可以使用，调用对象中函数，称之为方法调用
- 也可以添加形参和实参

![image-20241104094404873](C:\Users\12514\AppData\Roaming\Typora\typora-user-images\image-20241104094404873.png)





#### 3.遍历对象

- 遍历对象

​	for遍历对象的问题

- 对象没有像数组一样的length属性，所以无法确定长度
- 对象里面是无序的键值对，没有规律，不像数组里面由规律的下标

![image-20241104095133986](C:\Users\12514\AppData\Roaming\Typora\typora-user-images\image-20241104095133986.png)

- 一般不用这种方式遍历数组，主要是用来遍历对象
- **for in语法**中的k是一个变量，在循环的过程中一次代表对象的属性名
- 由于k是变量，所以必须使用[]语法解析
- 一定记住：**k**是获得对象的**属性名，对象名[k]**是获得**属性值**



#### 4.内置对象

- 介绍：Math对象是JavaScript提供的一个"数学"对象
- 作用：提供了一系列做数学运算的方法
- Math对象包含的方法有：
  - random：生成0-1之间随机数（包含0不包括1）
  - ceil：向上取整
  - floor：向下取整
  - max：找最大值
  - min：找最小值
  - pow：幂运算
  - abs：绝对值
  - …

##### 4.内置对象-生成任意范围随机数

- Math.random() 随机数函数， 返回一个0 - 1之间，并且包括0不包括1的随机小数 [0, 1）

![image-20241104101710593](C:\Users\12514\AppData\Roaming\Typora\typora-user-images\image-20241104101710593.png)

#### 拓展-术语解释

| 术语           | 解释                                                         | 举例                                              |
| -------------- | ------------------------------------------------------------ | ------------------------------------------------- |
| 关键字         | 在JavaScript中有特特殊意义的词汇                             | let、var、function、if、else、switch、case、break |
| 保留字         | 在目前的JavaScript中没有意义，在未来可能会具有特殊意义的词汇 | int、short、long、char                            |
| 标识（标识符） | 能产生值的代码，一般配合运算符出现                           | 10+3、age>=18                                     |
| 语句           | 一段可执行的代码                                             | if() for()                                        |
|                |                                                              |                                                   |

#### 拓展-基本数据类型和引用数据类型

​	简单类型又叫做基本数据类型或者值类型，复杂类型又叫做引用类型

- 值类型：简单数据类型/基本数据类型，在存储时变量中存储的时值本身，因此叫做值类型string ，number，boolean，undefined，null
- 引用类型：复杂数据类型，在存储时变量中存储的仅仅是地址（引用），因此叫做引用数据类型。通过 new 关键字创建的对象（系统对象、自定义对象），如 Object、Array、Date等



##### **堆栈空间区别：**

1. 栈（操作系统）：由操作系统自动分配释放存放函数的参数值、局部变量的值等。其操作方法类似于数据结构中的栈；

   **简单数据类型放到栈里面**

2. 堆（操作系统）：存储复杂类型(对象)，一般由程序员分配释放，若程序员不释放，由垃圾回收机制回收。

   **引用数据类型存放到堆里面**

![image-20241104110133692](C:\Users\12514\AppData\Roaming\Typora\typora-user-images\image-20241104110133692.png)

##### 1.简单数据类型的内存分配

- 值类型（简单数据类型）：string、number、boolean、undefined、null
- 值类型变量的数据直接存放在变量（栈空间）中

![image-20241104110745916](C:\Users\12514\AppData\Roaming\Typora\typora-user-images\image-20241104110745916.png)

##### 2.复杂数据类型的内存分配

- 引用数据类型（复杂数据类型）：通过new关键字创建的对象（系统对象、自定义对象），如果Object、Array、Date等
- 引用数据类型（栈空间）里面存放的是地址，真正的对象实例存放在堆空间中

![image-20241104112553453](C:\Users\12514\AppData\Roaming\Typora\typora-user-images\image-20241104112553453.png)

****

## Web APIs

### 1.DOM获取和属性操作

​	**变量声明**

- 变量声有三个 var、let、const
- 用哪个？首先var 先排除，老派写法，问题很多，可以淘汰掉…

- let or const ? 建议：**<u>const 优先</u>**，尽量使用const，原因是：
  - const语义化更好
  - 很多变量我们声明的时候就知道他不会被更改了，那为什么不用 const呢？
  - 实际开发中也是，比如react框架，基本const
- 有了变量先给const，如果发现它后面是要被修改的，再改为let

![image-20241118145000242](C:\Users\12514\AppData\Roaming\Typora\typora-user-images\image-20241118145000242.png)

#### 1.1 Web API基本认知

##### 	1.1.1作用和分类

- 作用：就是使用JS去操作html和浏览器
- 分类：**DOM**(文档对象模型)、BOM(浏览器对象模型)

![image-20241118145355880](C:\Users\12514\AppData\Roaming\Typora\typora-user-images\image-20241118145355880.png)

##### 1.1.2DOM

- DOM(Document Object Model——文档对象模型)是用来呈现以及与任意HTML或XML文档交互的API
- 白话文：DOM是浏览器提供的一套专门用来操作网页内容的功能

- DOM作用
  - 开发网页内容特效和实现用户交互

![image-20241118150133120](C:\Users\12514\AppData\Roaming\Typora\typora-user-images\image-20241118150133120.png)

##### 1.1.3DOM树

- DOM树是什么
  - 将HTML文档以树状结构直观的表现出来，称之为文档书或DOM树
  - 描述网页内容关系的名词
  - 作用：文档树直观的体现标签与标签之间的关系

![image-20241118150521128](C:\Users\12514\AppData\Roaming\Typora\typora-user-images\image-20241118150521128.png)

##### 1.1.4DOM对象

- DOM对象：浏览器根据html标签生成的JS对象
  - 所有的标签属性都可以在这个对象上面找到
  - 修改这个对象的属性会自动映射到标签身上
- DOM的核心思想
  - 把网页内容当作对象来处理
- document对象
  - 是DOM里面提供的对象
  - 所以它提供的属性和方法都是用来访问和操作网页内容的
    - 例：document.write()
  - 网页所有内容都在document里面

#### 1.2 获取DOM元素内容

##### 1.2.1根据CSS选择器来获取DOM元素（重点）

**1.选择匹配的第一个元素**

- **语法：**

- ```js
  document.querySelector('.css选择器')
  ```

- **参数：**

​			包含一个或多个有效的CSS选择器**<u>字符串</u>**

- **返回值：**

​			CSS选择器匹配的第一个元素，一个HTMLElement对象。

​			如果没有匹配到，则返回null

**2.选择匹配的多个元素**

- **语法：**

  ```js
  document.querySelectorAll('.css选择器')
  ```

- **参数：**

​			包含一个或多个有效的CSS选择器 **<u>字符串</u>**

- **返回值：**

​			CSS选择器匹配的NodeList 对象集合

- **例如：**		

```js
document.querySelectorAll('ul li')
```

​	得到的是一个**<u>伪数组：</u>**

- 有长度有索引的数组
- 但是没有pop() ,push()等数组方法

想要得到里面的每个对象，则需要遍历（for）的方式

> [!WARNING]
>
> 哪怕只有一个元素，通过querySelectAll()获取过来也是一个伪数组，立案只有一个元素而已

##### 1.2.2其他获取DOM元素方法（了解）

![image-20241118161056805](C:\Users\12514\AppData\Roaming\Typora\typora-user-images\image-20241118161056805.png)

#### 1.3 操作元素内容

##### 1.3.1对象.innerText属性

**1.元素innerText属性**

- 将文本内容添加到/更新到任意标签位置
- 显示春文本，不解析标签
- 例：

```js
const info = document.querySelector('.info')
//获取标签内部的文字
//console.log(info.innerHTML)
//添加/修改标签内部文字内容
info.innerText ='嗨喽，我是刘德华~'
```

##### 1.3.2 对象.innerHTML属性

- 将文本内容添加/更新到任意标签位置
- 会解析标签，多标签建议使用**模板字符串**
- 例：

```js
const info = document.querySelector('.info')
//获取标签内部的文字
//console.log(info.innerHTML)
//添加/修改标签内部文字内容
info.innerHTML =`嗨喽，我是<strong>刘德华</strong>~`
```

#### 1.4 操作元素属性

##### 1.4.1 操作元素常用属性

- 可以通过JS设置/修改**标签元素属性**，比如通过src更换图片
- 最常见的属性 比如：href、src等
- **语法:**

```js
对象.属性 = 值
```

- 例：

```js
//1.获取元素
const pic = document.querySelector('img')
//2.操作元素
pic.src = './images/b02.jpg'
pic.title = '刘德华演唱会'
```

##### 1.4.2操作元素样式属性

- 可以通过JS设置/修改元素的样式属性
  - 比如通过 轮播图小圆点自动更换颜色样式
  - 点击按钮可以滚动图片，这是移动的图片的位置left等等

**1.通过style属性操作css**

- **语法：**

```js
对象.style。样式属性 = 值
```

![image-20241118172542161](C:\Users\12514\AppData\Roaming\Typora\typora-user-images\image-20241118172542161.png)

**2.操作类名（className）操作CSS**

- 如果修改的样式比较多，直接通过style属性修改比较繁琐，可以通过借助css类名的形式
- **语法：**

```js
//actve是一个css类名
元素.className = 'active'
```

- 注意：
  1. 由于class是关键字，所以使用className去代替
  2. className是使用新值换旧值，如果需要添加一个类，需要保留之前的类名

**3.通过classList操作类控制CSS样式**

- 为了解决className 容易覆盖以前的类名，我们可以通过classList方式追加和删除类名
- **语法：**

```js
//追加一个类
元素.classList.add('类名')
//删除一个元素
元素.classList.move('类名')
//切换一个类名
元素.classList.toggle('类名')
```

##### 1.4.3操作表单元素属性

- 表单很多情况，也需要修改属性，比如点击眼睛，可以看到密码，本质是把表单转换为文本框

- 正常的有属性取值的，跟其他的标签属性没有任何区别

  - 获取:DOM对象.属性名
  - 设置：DOM对象.属性名 = 新值

  ```js
  表单.value ='用户名'
  表单.type = 'password'
  ```

- 表单属性中添加就有效果，移除就没有效果，一律使用布尔值表示，如果为true代表添加了该属性 如果是false代表移除了该属性
- 比如：disabled、checked、selected



##### 1.4.4自定义属性

- 标准属性：标签天生自带的属性，比如class、id 、title等，可以直接使用语法操作 比如：disabled、checked、selected
- 自定义属性：
  - 在html5中推出来了专门的data-自定义属性
  - 在标签上一律以**data-开头**
  - DOM对象上一律以**dataset对象方式**获取

```html
<body>
    <div class = "box" data-id ="10">盒子</div>
    <script>
        const box = document.querySelector('.box')
        console.log(box.dataset.id)
    </script>
</body>
```

#### 1.5 定时器-间歇函数

​	定时器函数可以开启和关闭定时器

##### 1.开启定时器

```js
setInterval(函数,间隔函数)
```

- 作用：每隔一段时间调用这个函数
- 间隔时间单位是毫秒

```js
function repeat(){
    console.log('哈哈哈哈哈哈')
}
//每间隔一秒调用repeat函数
setInterval(repeat,1000)  //函数repeat这里不需要加()
```

> [!CAUTION]
>
> 1.函数名字**不需要加括号**
>
> **2.定时器返回的是一个id数字**



**2.关闭定时器**

```js
let 变量名 = setInterval(函数,间隔时间)
clearInterval(变量名)
```

> [!CAUTION]
>
> 1.函数名字**不需要加括号**
>
> **2.定时器返回的是一个id数字**

一般不会刚创建就停止，而是满足一定条件再停止

```js
let timer = setInterval(function(){
    console.log('hi~~~')
},1000)
clearInterval(timer)
```

### 2.DOM事件基础

#### 2.1事件监听（绑定）

- **事件：**

  事件是在编程时系统内发生的**动作**或发生的事情

  比如用户在网页上**单击**一个按钮

- **事件监听**：

​		就是让程序检测是否又事件产生，一旦有事件触发，就立即调用一个函数做出响应，也成为绑定事件或注册事件

​		比如鼠标经过显示下拉菜单，比如点击可以播放轮番图等等

- **语法：**

```js
元素对象.addEventListener('事件类型',要执行的函数)
```

- 事件监听三要素：
  - **事件源：**哪个dom元素被事件触发了，要获取dom元素
  - **事件类型：**用什么方式触发，比如鼠标反击click，鼠标经过mouseover
  - **事件调用的函数：**要做什么事

```html
<button>按钮</button>
<script>
	const btn = document.querySelector('.btn')
    //修改元素样式
    tbn.addEventListener('click',function(){
        alert('点击了~')
    })
</script>
```

> [!CAUTION]
>
> 1.事件类型要加引号
>
> 2.函数事点击之后再去执行，每点击依次都会执行依次

**拓展-事件监听版本**

- DOM   L0

  事件源.on事件 = function(){}

- DOM  L2

  事件源.addEventListener(事件，事件处理函数)

- 区别

  on方式会被覆盖，**addEventListener**方式可绑定多次，拥有事件更多特性，推荐使用



#### 2.2事件类

![image-20250221101226437](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250221101226437.png)

#### 2.3事件对象

- 事件对象是什么
  - 也是个对象，这个对象里有事件触发时的相关信息
  - 例如：鼠标点击事件中，事件对象就存了鼠标点在哪个位置的信息
- 使用场景
  - 可以判断用户按下哪个键，比如按下回车键可以发布新闻
  - 可以判断鼠标点击了哪个元素，从而做相应的

##### 2.3.1获取事件对象

​	**语法：如何获取**

- 在事件绑定的回调函数的第一个参数就是事件对象
- 一般命名为event、ev、e

```js
元素.addEventListener('click',function(e){}) //e为事件对象
```

##### 2.3.2 事件对象常用属性

- 部分常用属性
  - type：获取当前的事件类型
  - clientX/clientY：获取光标相对于**浏览器可见窗口**左上角的位置
  - offsetX/offsetY：获取光标相当于**当前DOM元素**左上角的位置
  - key：用户按下的键盘键的值；现在不提倡使用keyCode

#### 2.4环境对象

​	**环境对象：**指的是函数内部特殊的**变量this**,它代表着当前函数运行时所处的环境

​	**作用：**弄清楚this的指向，可以让代码更简洁

- 函数的调用方式不同，this指代的对象也不同
- 【谁调用，this就是谁】是判断this指向的粗略规则
- 直接调用函数，其实相当于时window函数。所以this指代window

#### 2.5回调函数

​	如果将函数A作为餐宿传递给B 时，称函数A为回调函数

​	简单理解：当一个函数当作参数来传递给另外一个函数的时候，这个函数就是回调函数。

- 常见使用场景

```js
function fn(){
    console.log('我是回调函数…')
}
//fn传递给了setInterval，fn就是回调函数
setInterval(fn,1000)
```

```js
box.addEventListener('click',function(){
    console.log('我也是回调函数')
})
```



### 3.DOM事件进阶

#### 3.1事件流

##### 3.1.1事件流与两个阶段说明

- 事件流指的是事件完整执行过程中的流动路径

![image-20250221111909643](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250221111909643.png)

- 说明：假设页面里有个div，当触发事件时，会经历两个阶段，分别是捕获阶段、冒泡阶段
- 简单来说：捕获阶段是从父到子

##### 3.1.2事件捕获

- 事件捕获概念：从DOM的根元素开始去执行对应的事件(从外到里)
- 事件捕获需要写对应的代码才能看到效果
- 代码：

```js
DOM.addEventListener(事件类型,事件处理函数,是否使用捕获机制)
```

- 说明：
  - addEventListener第三个参数传入true代表是捕获阶段触发（很少使用）
  - 若传入false代表冒泡阶段触发，默认是false
  - 若是用L0事件监听，则只有冒泡阶段，没有捕获



##### 3.1.3事件冒泡

- **事件冒泡概念：**当一个元素的事件被触发时，同样的事件将会在该元素的所有祖先元素中依次被触发。这一过程被称为事件冒泡。

- 简单理解：当一个元素触发事件后，会依次向上调用所有父级元素的**<u>同名事件</u>**

- 事件冒泡时默认存在的

- L2事件监听第三个参数时false，或者默认都是冒泡

- ```js
  const father = document.querySelector('.father')
  const son = document.querySelector('.son')
  document.addEventListener('click',function(){
      alert('我是爷爷')
  })
  fa.addEventListener('click',function(){
      alert('我是爸爸')
  })
  son.addEventListener('click',function(){
      alert('我是儿子')
  })
  ```

  

##### 3.1.4阻止冒泡

- 问题：因为默认就有冒泡模式的存在，所以容易导致事件影响到父级元素

- 需求：若想吧事件限制在当前元素内，就需要阻止事件冒泡

- 前提：阻止事件冒泡需要拿到事件对象

- 语法：

- ```js
  事件对象.stopPropagation()
  ```

```js
const father = document.querySelector('.father')
const son = document.querySelector('.son')
document.addEventListener('click',function(){
    alert('我是爷爷')
})
fa.addEventListener('click',function(){
    alert('我是爸爸')
})
son.addEventListener('click',function(e){
    alert('我是儿子')
    //阻止冒泡
    e.stopPropagation()
})
```

- **注意：**此方法可以阻断事件流传播，不光在事件冒泡阶段有效，捕获阶段也有效

**某些情况下需要阻止默认行为的发生，比如阻止链接的跳转，表单域跳转**

- **语法：**

  ```js
  e.preventDefault()
  ```

  ![image-20241120100610196](C:\Users\12514\AppData\Roaming\Typora\typora-user-images\image-20241120100610196.png)

##### 3.1.5解绑事件

​	on事件方式，直接使用null覆盖偶就可以实现事件的解绑

- **语法：**

```js
//绑定事件
btn.onclick = function(){
    alert('点击了')
}
//解绑事件
btn.onclick = null
```

- addEventListener方式，必须使用：

  removeEventListener(事件类型, 事件处理函数, [获取捕获或者冒泡阶段])

  例如：：

```js
function fn(){
    alert('点击了')
}
//绑定事件
btn.addEventListener('click',fn)
//解绑事件
btn.removeEventListener('.click',fn)
```

<u>**注意：匿名函数无法被解绑**</u>

**鼠标经过事件的区别：**

- mouseover和mouseout会有冒泡效果
- mouseenter和mouseleave没有冒泡效果（推荐）

**两种注册事件的区别：**

- 传统on注册（L0）
  - 同一个对象，后面注册的事件会覆盖前面注册（同一个事件）
  - 直接使用null覆盖偶就可以实现事件的解绑
  - 都是冒泡阶段执行的
- 事件监听注册（L2）
  - 语法：addEventListener（事件类型，事件处理函数，是否使用捕获）
  - 后面注册的事件不会覆盖前面的注册的事件（同一个事件）
  - 可以通过第三个参数去确定是在冒泡或则捕获阶段执行
  - 必须使用removeEventListener（事件类型，事件处理函数，获取捕获或者冒泡阶段）
  - 匿名函数无法被解绑

#### 3.2事件委托

- **事件委托**是利用事件流的特征解决一些开发需求的知识技巧

  - 优点：减少注册次数，可以提高程序性能
  - 原理：事件委托其实就是利用事件冒泡的特点
    - 给**父元素注册事件**，当我们触发子元素的时候，会冒泡到父元素身上，从而触发父元素的事件
  - 实现：事件对象target.tagName可以获得正真触发事件的元素
    - ul.addEventListener('.click',function(){})执行父级点击事件

  ![image-20241120144328718](C:\Users\12514\AppData\Roaming\Typora\typora-user-images\image-20241120144328718.png)

  ```js
  const ul= document.querySelector('ul')
  ul.addEventListener('click',function(e){
      //console.log(e.target)
      if(e.target.tagName === 'LI'){
          this.style.color = 'pink'
      }
  })
  ```

#### 3.3其他事件

##### 3.3.1页面加载事件

- 加载外部资源（如图片、外联CSS和JavaScript等）加载完毕时触发的事件

- 事件名：load
- 监听页面所有资源加载完毕：
  - 给window添加load事件

```js
//页面加载事件
window.addEventListener('load',function(){
    //执行的操作
})
```

- 注意：不光可以监听整个页面资源加载完毕，也可以针某个资源绑定load事件



- 当初始的HTML文档被完全加载和解析完成之后，DOMcontentLoaded事件被触发，而无需等待样式标、图像等完全加载
- 事件名：DOMcontentLoaded
- 监听页面DOM加载完毕：
  - 给document添加DOMContentLoaded事件

```js
document.addEventListener('DOmContentLoaded',function(){
    //执行操作
})
```

##### 3.3.2元素滚动事件

- **元素滚动事件** ： 滚动条在滚动的时候持续触发的事件

​	很多网页需要检测用户把页面滚动到某个区域后做一些处理， 比如固定导航栏，比如返回顶部

- 事件名：scroll
- 监听整个页面滚动：

```js
//页面滚动事件
window.addEventListener('scroll',fuuncion(){
     //执行操作
})
```

- 给window或document添加scroll事件

- 监听某个元素的内部滚动直接给某个元素加即可

​	**页面滚动事件-获取位置**

- scrollLeft和scrollTop(属性)
  - 获取被卷去的大小
  - 获取元素内容往左、往上滚出去看不到的距离
  - 这两个值是可读的
- 尽量在scroll事件里面获取被卷去的距离

```js
div.addEventListener('.scroll',function(){
    console.log(this.scrollTop)
})
```

![image-20241120172118258](C:\Users\12514\AppData\Roaming\Typora\typora-user-images\image-20241120172118258.png)

- 开发中，我们经常检测页面滚动的距离，比如页面滚动100像素，就可以显示一个元素，或者固定一个元素

```js
//页面滚动事件
window.addEventListener('.scroll',function(){
    //document.documentElement 是html元素获取方式
    const.n = document.documentElement.scrollTop
    console.log(n)
})
```

![image-20241120172532147](C:\Users\12514\AppData\Roaming\Typora\typora-user-images\image-20241120172532147.png)

- scrollTo()方法可把内容滚动到指定坐标

- **语法：**

  元素.scrollTo(x,y)

- 例如：

  ```js
  //让页面滚动到y轴1000像素的位置
  window.scrollTo(0,1000)
  ```

##### 3.3.3页面尺寸事件

- 会在窗口尺寸改变的时候触发事件：

  - resize

  ```js
  window.addEventListener('.resize',function(){
      //执行的代码
  })
  ```

- 检测屏幕宽度

```js
window.addEventListener('.resize',function(){
    let w = document.documentElement.clientWidth
    console.log(w)
})
```

![image-20241120173733790](C:\Users\12514\AppData\Roaming\Typora\typora-user-images\image-20241120173733790.png)

- 获取宽高：
  - 获取元素的可见部分宽高（不包含边框，margin，滚动等）
  - clientWidth和clientHight

#### 3.4元素尺寸于位置

- 使用场景：
  - 前面案例滚动多少距离，都是我们自己算的，最好是页面滚动到某个元素，就可以做某些事。
  - 简单说，就是通过js的方式，得到元素在页面中的位置
  - 这样我们可以做，页面滚动到这个位置，就可以做某些操作，省去计算了

![image-20241120174226008](C:\Users\12514\AppData\Roaming\Typora\typora-user-images\image-20241120174226008.png)

- 获取宽高：

  - 获取元素的自身宽高、包含元素自身设置的宽高、padding、border
  - offsetWidth和offsetHeight
  - 获取出来的数值，计算方便
  - 注意：获取的时可视宽高，如果盒子是隐藏的，获取的结果是0

- 获取位置：

  ​	1、offsetLeft和offsetTop 注意是只读属性

  - 获取元素距离自己定位父级元素的左、上距离

![image-20241120174801666](C:\Users\12514\AppData\Roaming\Typora\typora-user-images\image-20241120174801666.png)

​			2、element.getBoundingClientRect()

​				方法返回元素的大小及其相对于视口的位置

​	<u>**总结：**</u>

| 属性                      | 作用                                     | 说明                                                     |
| ------------------------- | ---------------------------------------- | -------------------------------------------------------- |
| scrollLeft和scrollTop     | 被卷去的头部和左侧                       | 配合页面滚动来写，可读写                                 |
| clientWidth和clientHight  | 获得元素宽度和高度                       | 不包含border，margin，滚动条用于js获取元素大小，只读属性 |
| offsetWidth和offsetHeight | 获得元素宽度和高度                       | 包含border，margin，滚动条用于js获取元素大小，只读属性   |
| offsetLeft和offsetTop     | 获取元素距离自己定位父级元素的左、上距离 | 获取元素位置的时候使用，可读属性                         |



### 4.DOM节点&移动端滑动

#### 4.1日期对象

- 日期对象：用来表示时间的对象
- 作用：可以得到当前系统时间

##### 4.1.1实例化

- **在代码中发现了new关键字时，一般将这个操作称为<u>实例化</u>**
- **创建一个时间对象并获取时间**
- 1.获得当前时间	

```js
const date = new Date()
```

- 2.获得指定时间

```js
const date = new Date('2008-8-8')
console.log(date)
```

##### 4.1.2时间对象方法

- **使用场景：**因为日期对象返回的数据不能直接使用，所以需要转换为实际开发中常用的格式

| 方法          | 作用               | 说明                 |
| ------------- | ------------------ | -------------------- |
| getFullYear() | 获得年份           | 获取四位年份         |
| getMonth()    | 获得月份           | 取值为0~11           |
| getDate()     | 获取月份中的每一天 | 不同月份取值也不相同 |
| getDay()      | 获取星期           | 取值为0~6            |
| getMinutes()  | 获取分钟           | 取值为0~59           |
| getMinutes()  | 获取秒             | 取值为0~59           |
|               |                    |                      |

##### 4.1.3时间戳

​	**使用场景：**如果计算倒计时的效果，前面方法无法直接计算，需要借助时间戳完成

​	**什么是时间戳：**是指1970年01月01日00时00分00秒起至现在的**<u>毫秒数</u>**,他是一种特殊的计量数量的方式

​	**算法：**

- 将来的时间戳-现在的时间戳 = 剩余时间毫秒数
- 剩余时间毫秒数 转换为 剩余时间的 年月日时分秒 就是倒计时
- 比如 将来时间戳2000ms-现在时间戳1000ms = 1000ms
- 1000ms 转换为 0小时0分1秒

​	**三种方式获取时间戳：**

1. 使用getTime()方法

   ```js
   const date = new Date()
   console.log(date.getTime())
   ```

2. 简写+new Date()

   ```js
   console.log(+new Date())
   ```

3. 使用Date.now()

   1. 无需实力化
   2. 但是只能得到当前的时间戳，而前面两种可以返回指定时间的时间戳

#### 4.2节点操作

##### 4.2.1DOM节点

- DOM节点

  - DOM树里面每一个内容称为节点

- 节点类型

  - 元素节点
    - 所有的标签 比如body、div
  - 属性节点
    - 所有属性 比如href
  - 文本节点
    - 所有的文本
  - 其他

  ![image-20241120203133857](C:\Users\12514\AppData\Roaming\Typora\typora-user-images\image-20241120203133857.png)

##### 4.2.2查找节点

- 关闭二维码案例：

  ​	点击关闭按钮，关闭的是二维码的盒子，还有获取erweima盒子

- 思考：

  - 关闭按钮和erweima是关系？父子关系
  - 所以，可以这么做：嗲及关闭按钮，直接关闭它的爸爸，就无需获取erweima元素了

- 节点关系：针对的找返回的都是对象

  - 父节点
  - 子节点
  - 兄弟节点

![image-20241120203547247](C:\Users\12514\AppData\Roaming\Typora\typora-user-images\image-20241120203547247.png)

- **父节点查找：**
  - parentNode属性
  - 返回最近一级的父节点 找不到返回为null

```js
子元素.parentNode
```

- **子节点查找：**

  - childNodes

    - 获得所有子节点，包含文本节点（空格、换行）、注释节点等

  - children属性（重点）

    - 仅获得所有元素节点
    - 返回的还是一个伪数组

    ```js
    父元素.children
    ```

- **兄弟关系查找：**

  1.下一个兄弟节点

  - nextElementSibling属性

  2.上一个兄弟节点

  - previousElementSibling属性

##### 4.2.3增加节点

​	**1.创建节点**

- 创造出一个新的网页元素，再添加到网页内，一般先创建节点，然后插入节点
- 创建元素节点的方法：	

```js
//创建一个新的元素节点
document.createElement('表签名')
```

​	**2.追加节点**

- 想要再界面看到，还得插入到某个父元素中

- 插入到父元素的最后一个元素：

  ```js
  //插入到这个父元素的最后
  父元素.appendChild(要插入的元素)
  ```

- 插入到父元素中某个子元素的前面	

```js
//插入到某个子元素的前面
父元素.insertBefore(要插入的元素，在哪个元素前面)
```

- 特殊情况下，新增节点咱找如下操作：

  - 复制一个原有节点

  - 把复制的节点放入到到指定的元素内部

- 克隆节点

  ```js
  //克隆一个已有的元素节点
  元素.cloneNode(布尔值)
  ```

  cloneNode会克隆出一个跟原标签一样的元素，括号内传入布尔值

  - 若为true，则代表克隆时会包含后代节点一起克隆
  - 若为false，则代表克隆时不包含后代节点
  - 默认为false

##### 4.2.4删除节点

- 若一个节点再页面中方已不需要时，可以删除它
- 在JavaScript原生Dom操作中，要删除元素必须通过父元素删除
- **语法**

```js
父元素.removeChild(要删除的元素)
```

- 注：
  - 如不存在父子关系则删除不成功
  - 删除节点和隐藏节点(display:name)  有区别的：隐藏节点还是存在的，但是删除，则从html中删除

#### 4.3M端事件

​	移动端也有自己独特的地方。比如触屏事件 touch（也称为触摸事件），Android和IOS都有。

- 触屏事件  touch（也称触摸事件），Android和IOS都有。
- touch对象代表一个触摸点。触摸点可能是一根手指，也可能是一根触摸笔。触屏事件可响应用户手指（或触控笔）对屏幕或者触控板操作
- 常见的触屏事件如下：

​	

| 触屏touch事件 | 说明                          |
| ------------- | ----------------------------- |
| touchstrat    | 手指触摸到一个DOM元素时触发   |
| touchmove     | 手指在一个DOM元素上滑动时触发 |
| touchmove     | 手指从DOM元素上移开时触发     |

#### 4.4JS插件

- **插件：**就是别人写好一些代码，我们只需要复制对对应的代码，就可以直接实现对应的效果
- 学习插件的基本过程：
  - 熟悉官网，了解这个插件可以完成什么需求：https://www.swiper.com.cn/
  - 看在线演示，找到符合自己需求的demo：https://www.swiper.com.cn/demo/index.html
  - 查看基本使用流程：https://www.swiper.com.cn/usage/index.html
  - 查看APi文档，去配置自己的插件：https://www.swiper.com.cn/api/index.html
  - **注意：**多个swiper同时使用的时候，类名需要注意区分

![image-20241120211824895](C:\Users\12514\AppData\Roaming\Typora\typora-user-images\image-20241120211824895.png)



![image-20241120211947140](C:\Users\12514\AppData\Roaming\Typora\typora-user-images\image-20241120211947140.png)

![image-20241120211956797](C:\Users\12514\AppData\Roaming\Typora\typora-user-images\image-20241120211956797.png)

![image-20241120212005704](C:\Users\12514\AppData\Roaming\Typora\typora-user-images\image-20241120212005704.png)

![image-20241120212019934](C:\Users\12514\AppData\Roaming\Typora\typora-user-images\image-20241120212019934.png)





### 5.Bom操作

#### 5.1window对象

##### 5.1.1 BOM（浏览器对象模型）

- BOM（Browser Object Model）是浏览器对象模型

![image-20241120212450813](C:\Users\12514\AppData\Roaming\Typora\typora-user-images\image-20241120212450813.png)

- window对象是一个全局对象，也可以说是JavaScript中的顶级对象
- 像document、alert()、consloe.log()这些都是window的属性，基本BOM的属性和方法都是window的
- 所有通过var定义在全局作用域中的变量、函数都会变成window对象的属性和方法。
- window对象下的属性和方法调用的时候可以省略window

##### 5.1.2定时器-延时函数

JaveScript内置的一个用啦让嗲吗延迟执行的函数，叫setTimeout

**语法：**

```js
setTimeout(回调函数，等待的毫秒数)
```

setTimeout仅仅只执行一次，所以可以理解为就是把一段代码延迟执行，平时省略window

**清除延时函数：**

```js
let timer = setTimeout(回调函数，等待的毫秒数)
clearTimeout(timer)
```

**注意点**

- 掩饰其需要等待，所以后面的代码先执行
- 每一次调用延时器都会产生一个新的延时器

**两种定时器对比：**

- 延时函数：执行一次
- 间歇函数：每隔一段时间就执行一次，除非手动清除



##### 5.1.3JS执行机制

![image-20241120214504169](C:\Users\12514\AppData\Roaming\Typora\typora-user-images\image-20241120214504169.png)

​	JavaScript语言最大的特点就是**单线程**，也就是说，同一个事件只能做一件事。

​	这是因为JavaScript这门脚本语言诞生的使命所致——JavaScript是为处理页面中用户的交互，以及操作DOM而诞生的。比如我们对某个DOM元素进行添加和删除操作，不能同时进行。应该先进行添加，之后再删除。

​	单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。这样所导致的问题是：如果JS执行的事件过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞的感觉。

- 为了解决这个问题，利用多喝CPU的计算能力HTML5提出Web Worker标准，允许JavaScrip脚本创建多个线程。JS出现了**同步**和**异步**。

  **同步**

  ​	前一个任务结束后在执行后一个任务，程序的执行顺序排序是一致的、同步的。比如做饭的同步做法：要烧水煮饭，等水开了（10分钟之后），再去切菜、炒菜

  **异步**

  你在做一件事时，以为这件事情会花费很长时间，在做这件事的同时，你还可以去处理其他事情。比如做饭的异步做法，在烧水的同时，利用这10分钟，去切菜，炒菜。

  **他们的本质区别：这条流水线上各个流程的执行顺序不同。**

###### 	同步任务

同步任务都在主线程上执行，形成一个执行栈。

###### 	异步任务

JS的异步是通过回调函数实现的

一般而言异步任务有以下三种类型：

1.普通事件，如click、resize等

2.资源加载，如load、error等

3.定时器，包括setInterval、setTimeout等

异步任务相关添加到**任务列队**中（任务队列也成为消息队列）

![image-20241121103831302](C:\Users\12514\AppData\Roaming\Typora\typora-user-images\image-20241121103831302.png)

1. 先执行**执行栈中的同步任务**.
2. 异步任务放入任务队列中。
3. 一旦执行栈中的所有同步任务执行完毕，系统就会按次序读取任务队列中的异步任务，于是被读取的异步任务结束等待状态，进入执行栈，开始执行。

![image-20241121103921494](C:\Users\12514\AppData\Roaming\Typora\typora-user-images\image-20241121103921494.png)

![image-20241121104254823](C:\Users\12514\AppData\Roaming\Typora\typora-user-images\image-20241121104254823.png)

**由于主线程不断的重复获得任务、执行任务、再获取任务、再执行，所以这种机制被称为<u>事件循环（event loop）</u>。**

##### 5.1.4location对象

- location 的数据类型是对象，它拆分并保存了URL地址各个组成部分

- **常用属性和方法：**

  - href属性获取完整的URL地址，对其赋值时用于地址的跳转

    ![image-20241121112120989](C:\Users\12514\AppData\Roaming\Typora\typora-user-images\image-20241121112120989.png)

  - search属性获取地址中携带的参数，符号？后面部分

    ![image-20241121112205274](C:\Users\12514\AppData\Roaming\Typora\typora-user-images\image-20241121112205274.png)

  - hash属性获取地址中的哈希值，符号#后面部分

    ![image-20241121112235021](C:\Users\12514\AppData\Roaming\Typora\typora-user-images\image-20241121112235021.png)

  - reload 方法用来刷新当前页面，传入参数true时表示强制刷新

    ![image-20241121112315600](C:\Users\12514\AppData\Roaming\Typora\typora-user-images\image-20241121112315600.png)

​				

##### 5.1.5navigator对象

- navigator的数据类型是对象，该对象下记录了浏览器自身的相关信息

- **常用属性和方法**:

  - 通过 userAgent 检测浏览器的版本及平台

  ![image-20241121112450659](C:\Users\12514\AppData\Roaming\Typora\typora-user-images\image-20241121112450659.png)

##### 5.1.6history对象

- history 的数据类型是对象，主要管理历史记录， 该对象与浏览器地址栏的操作相对应，如前进、后退、历史记录等
- **常用方法和属性**

​	

| history对象方法 | 作用                                                         |
| --------------- | ------------------------------------------------------------ |
| back()          | 可以后退功能                                                 |
| forward()       | 前进功能                                                     |
| go(参数)        | 前进后退功能 参数如果是1，前进1个页面 ；如果是-1，后退1个页面 |

history对象一般在实际开发中比较少用，但是会在一些OA办公系统中见到。

![image-20241121112921770](C:\Users\12514\AppData\Roaming\Typora\typora-user-images\image-20241121112921770.png)

#### 5.2本地存储

##### 5.2.1本地存储分类

- localStorage
- SessionStorage

###### localStorage

- 作用：可以将数据永久储存在本地(用户的电脑)，除非手动删除，否则关闭页面也会存在

- 特性：

  - 可以多窗口（页面）共享（同一浏览器可以共享）
  - 以键值对的形式存储使用

- 语法：

  **存储数据：**

  ```js
  localStorage.setItem(key,value)
  ```

  **获取数据：**

  ```js
  localStorage.getItem(key)
  ```

  **删除数据：**

  ```js
  localStorage.removeItem(key)
  ```

- 浏览器查看本地数据

  ![image-20241121113926029](C:\Users\12514\AppData\Roaming\Typora\typora-user-images\image-20241121113926029.png)

###### sessionStorage

- **特性：**
  - 生命周期为关闭浏览器窗口
  - 在同一个窗口(页面)下数据可以共享
  -  以键值对的形式存储使用
  - 用法跟localStorage 基本相同

##### 5.2.2存储复杂数据类型

- 本地只能存储字符串，无法存储复杂数据类型

  ```js
  const goods = {
      name:'小米10',
      price:1999
  }
  locatStorage.setItem('goods',goods)
  ```

  ![image-20241121152746525](C:\Users\12514\AppData\Roaming\Typora\typora-user-images\image-20241121152746525.png)

- **解决：**需要将复杂数据类型转换成JSON字符串
- **语法：**JSON.stringify(复杂数据类型)

```js
const goods = {
    name:'小米10',
    price:1999
}
localStorage.setItem('goods',JSON.stringify(goods))
```

- 将复杂数据转换成JSON字符串  **存储**本地存储中


![image-20241121165823216](C:\Users\12514\AppData\Roaming\Typora\typora-user-images\image-20241121165823216.png)	

- **问题：**因为本地存储里面取出来的是字符串，无法直接使用

  ```js
  const obj = localStorage.getItem('goods')
  console.log(obj)
  ```

  ![image-20241121171013950](C:\Users\12514\AppData\Roaming\Typora\typora-user-images\image-20241121171013950.png)



- **解决：**把取出来的字符串转换成对对象

- **语法：JSON.parse(JSON字符串)**

  ```js
  const obj = JSON.parse(localStorage.getItem('goods'))
  ```

  - 将JSON字符串转换成对象  **取出**时候使用

    ![image-20241121173410619](C:\Users\12514\AppData\Roaming\Typora\typora-user-images\image-20241121173410619.png)





![image-20241121173444031](C:\Users\12514\AppData\Roaming\Typora\typora-user-images\image-20241121173444031.png)

![image-20241121173455263](C:\Users\12514\AppData\Roaming\Typora\typora-user-images\image-20241121173455263.png)

![image-20241121173512792](C:\Users\12514\AppData\Roaming\Typora\typora-user-images\image-20241121173512792.png)

![image-20241121173624249](C:\Users\12514\AppData\Roaming\Typora\typora-user-images\image-20241121173624249.png)

![image-20241121173641302](C:\Users\12514\AppData\Roaming\Typora\typora-user-images\image-20241121173641302.png)



### 6.正则&阶段案例

#### 6.1正则表达

##### 6.1.1介绍

​	**正则表达式**（Regular Expression）是用于匹配字符串中字符组合的模式。在 JavaScript中，正则表达式也是对象。

​	<u>通常用来查找、替换那些符合正则表达式的文本，许多语言都支持正则表达式。</u>

**正则表达式在 JavaScript中的使用场景：**

- 例如验证表单：用户名表单只能输入英文字母、数字或者下划线， 昵称输入框中可以输入中文(匹配)
  - 比如用户名: /^[a-z0-9_-]{3,16}$/
  - 过滤掉页面内容中的一些敏感词(替换)，或从字符串中获取我们想要的特定部分(提取)等 。

![image-20241121174850447](C:\Users\12514\AppData\Roaming\Typora\typora-user-images\image-20241121174850447.png)

##### 6.1.2语法

- 我们想要查找是否有戴眼镜的人, 怎么做呢？
  1. 定义规则： 戴眼镜的
  2. 根据规则去查找：找到则返回
- 正则同样道理，我们分为两步：
  1. 定义规则
  2. 查找
- 比如：查找下面文本中是否包含字符串 '前端'

```js
let str = 'IT培训,前端开发培训,web前端培训,软件测试培训,产品经理培训'
```

![image-20241121175025554](C:\Users\12514\AppData\Roaming\Typora\typora-user-images\image-20241121175025554.png)

- JavaScript 中定义正则表达式的语法有两种，我们先学习其中比较简单的方法：

- **1.定义正则表达式语法：**

  ```js
  const 变量名 = /表达式/
  ```

- 其中 /     /是正则表达式字面量

- 比如：

  ```js
  const reg = /前端/
  ```

- **2.判断是否有符合规则的字符串**

  test()方法  用来查看正则表达式与指定的字符串是否匹配

- **语法：**

  ```js
  regObj.test(被检测的字符串)
  ```

- 比如：

```js
//要检测的字符串
const str = 'IT培训，前端开发培训，IT培训课程，web前端培训，Java培训，人工智能培训'
//1.定义正则表达式，检测规则
const reg = /前端/
//2.检测方法
console.log(reg.test(str))//true
```

- 如果正则表达式与指定的字符串匹配，返回true，否则false

​	**3.检索（查找）符合规则的字符串：**

​	exec() 方法  在一个指定字符串中执行一个搜索匹配

- **语法：**

  ```js
  regObj.exec(被检测字符串)
  ```

- 比如：

  ```js
  //要检测的字符串
  const str = 'IT培训，前端开发培训，IT培训课程，web前端培训，Java培训，人工智能培训'
  //1.定义正则表达式，检测规则
  const reg = /前端/
  //2.检测方法
  console.log(reg.exec(str))
  ```

  ![image-20241121202134945](C:\Users\12514\AppData\Roaming\Typora\typora-user-images\image-20241121202134945.png)

- 如果匹配成功，exec()方法返回一个数组，否则返回null			

​	<u>正则表达式检测查找 test方法和exec方法有什么区别？</u>

- test方法 用于判断是否有符合规则的字符串，返回的是布尔值 找到返回true，否则false
- exec方法用于检索（查找）符合规则的字符串，找到返回数组，否则为 null

##### 6.1.3元字符

- **普通字符**

  大多数的字符仅能够描述它们本身，这些字符称作普通字符，例如所有的字母和数字。
  也就是说普通字符只能够匹配字符串中与它们相同的字符。

- **元字符（特殊字符）**

  是一些具有特殊含义的字符，可以极大提高了灵活性和强大的匹配功能。

  - 比如，规定用户只能输入因为26个英文字母，普通字符的话abcdefghijklm…..
  - 但是换成元字符串写法：[a-z]

- **参考文档**

  - MDN：https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions
  - 正则测试工具: http://tool.oschina.net/regex





​	<u>为了方便记忆和学习，对元字符进行了分类：</u>

- 边界符（表示位置，开头和结尾，必须用什么开头，用什么结尾）

- 量词（表示重复次数）

- 字符类（\d  表示0~9）

  

​	**1.边界符**

- 正则表达式中的边界符（位置符）用来**提示字符所处的位置**,主要有两个字符

  | 边界符 | 说明                           |
  | ------ | ------------------------------ |
  | ^      | 表示匹配行首的文本（以谁开始） |
  | $      | 表示匹配行尾的文字（以谁结束） |

  **如果^和$在一起，表示必须精确匹配**

```js
console.log(/哈/.test('哈'))//true
console.log(/二哈/.test('二哈'))//true
console.log(/二哈/.test('很二哈哈哈哈'))//true

//^开头
console.log(/^二哈/.test('很二哈哈'))//false
console.log(/^二哈/.test('二哈很傻'))//true
//$结尾
console.log(/二哈$/.test('二哈很傻'))//false
console.log(/二哈$/.test('二哈二哈'))//false
console.log(/二哈$/.test('二哈'))//true
```

​	**2.量词**

- 量词用来设定某个模式出现发频次

  | 量词  | 说明             |
  | ----- | ---------------- |
  | *     | 重复零次或更多次 |
  | +     | 重复一次或更多次 |
  | ？    | 重复零次或一次   |
  | {n}   | 重复n次          |
  | {n,}  | 重复n次或更多次  |
  | {n,m} | 重复n到m次       |

​	**注意；逗号左右两侧千万不要出现空格**

```js
// * 表示重复0次或者更多次
console.log(/^哈*$/.test('')) // true
console.log(/^哈*$/.test('哈')) // true
console.log(/^哈*$/.test('哈哈哈')) // true
//+ 表示重复1 次或者更多次
console.log(/^哈+$/.test('')) // false
console.log(/^哈+$/.test('哈')) // true
console.log(/^哈+$/.test('哈哈哈')) // true
//?表示重复0次或者1次   0 // 1
console.log('------')
console.log(/^哈?$/.test('')) // true
console.log(/^哈?$/.test('哈')) // true
console.log(/^哈?$/.test('哈哈哈')) // fasle
```

```js
console.log(/^哈{2}$/.test('')) // false
console.log(/^哈{2]$/.test('哈')) // false
console.log(/^哈{2J$/.test('哈哈')) // true
console.log(/^哈{2J$/.test('哈哈哈')) // false
```

```js
//{n,}是 >= n 的意思
console.log(/^哈{2,}$/.test('')) // false
console.Iog(/^哈{2,}$/.test('哈')) // false
console.log(/^哈{2,}$/.test('哈哈')) // true
console.log(/^哈{2,}$/.test( '哈哈哈')) // true
```

```js
// {n,m] 是 次数 >= n <= m 的意思 注意，逗号左右千万不要有空格
console.log(/^哈[2,4]$/.test('')) // false
console.log(/^哈{2,4J$/.test('哈')) // false
console.log(/^哈[2,4]$/.test('哈哈')) // true
console.log(/^哈{2,4]$/.test('哈哈哈')) // true
console.log(/^哈{2,4J$/.test('哈哈哈哈')) // true
console.log(/^哈{2,4}$/.test('哈哈哈哈哈')) // false
```

​	**3.字符类：**

​	(1) 1.[   ]匹配字符合集

- 后面的字符串只要包含abc中任意一个字符串，都返回true。

  ```js
  //只要中括号里面的任意字符出现都返回true
  console.log(/[abc]/.test('andy'))//true
  console.log(/[abc]/.test('andy'))//true
  console.log(/[abc]/.test('cry'))//true
  console.log(/[abc]/.test('die'))//false
  ```

​	2.[  ]里面加上 - 连字符

- 使用连字符 - 表示一个范围	

```js
console.log(/^[a-z]$/.test('c'))//true
```

- 比如：

  -  [a-z] 表示 a 到 z 26个英文字母都可以
  -  [a-zA-Z] 表示大小写都可以
  -  [0-9] 表示 0~9 的数字都可以

- 认识下：

  ```js
  腾讯QQ号：^[1-9][0-9]{4,}$ (腾讯QQ号从10000开始)
  ```

  3.[  ]里面加上 ^ 取反符号

- 比如

  - [^a-z]匹配除了小写字母以外的字符

  - 注意要写到中括号里面

    

  (2) . 匹配除换行符之外的任何单个字符

  (3) 预定义：指的是某些常见模式的简写方式

  ![image-20241121213046284](C:\Users\12514\AppData\Roaming\Typora\typora-user-images\image-20241121213046284.png)

```js
日期格式：^\d{4}-\d{1,2}-\d{1,2}
```

##### 6.1.4修饰符

- 修饰符约束正则执行的某些细节行为，如是否区分大小写、是否支持多行匹配等

- **语法：**

  ```js
  /表达式/修饰符
  ```

  - i是单词ignore的缩写，正则匹配时字母不区分大小写

  - g是单词global的缩写，匹配所有满足正则表达式的结果

    ```js
    console.log(/a/i.test('a')) //true
    console.log(/a/i.test('A')) //true
    ```

- **替换replace 替换**

- **语法：**

  ```js
  字符串.replace(/正则表达式/，'替换的文本')
  ```

  



****



## JS高级

### 1.作用域

- 作用域（scope）规定了变量能够被访问的"范围"，离开了这个“范围”变量便不能被访问

​	**作用域分为：**

1. 局部作用域
2. 全局作用域

#### 局部作用域

​	局部作用域分为函数作用域和块作用域

###### 函数作用域：

​	在函数内部声明的变量只能在函数内部被访问，外部无法直接访问。

![image-20241104115030665](C:\Users\12514\AppData\Roaming\Typora\typora-user-images\image-20241104115030665.png)

**总结：**

1. 函数内部声明的变量，在函数外部无法被访问
2. 函数的参数也是函数内部的局部变量
3. 不同函数内部声明的变量无法互相访问
4. 函数执行完毕后，函数内部的变量实际被清空了



###### 块级作用域

​	在 JavaScript 中使用 { } 包裹的代码称为代码块，代码块内部声明的变量外部将【有可能】无法被访问。

```js
for(let t = 1; t<=6;t++){
    //t只能在该代码块中被访问
    console.log(t)//正常
}
//超出了t的作用域
console.log(t)//报错
```

**总结：**

1. let 声明的变量会产生块作用域，var 不会产生块作用域
2. const 声明的常量也会产生块作用域
3. 不同代码块之间的变量无法互相访问
4. 推荐使用 let 或 const

#### 全局作用域

<script> 标签 和 .js 文件 的【最外层】就是所谓的全局作用域，在此声明的变量在函数内部也可以被访问。
全局作用域中声明的变量，任何其它作用域都可以被访问

```js
<script>
    //全局作用域
    //全局作用域下声明了num变量
    const num = 10
	function fn(){
        //函数内部可以使用全局作用域的变量
        console.log(num)
    }
//此处全局作用域
</script>
```

> [!WARNING]
>
> 1.为window对象动态添加的属性默认也是全局的，不推荐！！！
>
> 2.函数中未使用任何关键字声明的变量为全局变量，不推荐！！！
>
> 3.尽可能少的声明全局变量，防止全局变量被污染

#### 作用域链

作用域链本质上是底层的变量查找机制

- 在函数被执行时，会有线查找当前函数作用域中查找变量
- 如果当前作用域查找不到则会依次逐级查找父级作用域直到全局作用域

```js
<script>
    //全局作用域
    let a = 1
	let b = 2
    //局部作用域
    function f(){
        let a = 1
        //局部作用域
        function g(){
            a=2
            console.log(a)
        }
        g()//调用g
    }
	f()//调用f
</script>
```

#### JS垃圾回收机制

##### 1.什么是垃圾回收机制？

​	垃圾回收机制（Garbage Collection） 简称GC

​	JS中内存的分配和回收都是自动的，内存在不使用的时候会被垃圾回收器自动回收

​	正因为垃圾回收器的存在，许多人认为JS不用太关心内存管理的问题。，但是如果不了解JS的内存管理机制，我们同样非常容易存在内存泄漏（内存无法被回收）的情况

不再用到的内存，没有及时释放，就叫**<u>内存泄漏</u>**

##### 2.内存生命周期

​	JS环境中分配的内存，一般有如下生命周期：

1. 内存分配：当声明变量、函数、对象的时候，系统会自动为他们分配内存
2. 内存使用：即读写内存，也就是使用变量、函数等
3. 内存回收：使用完毕，由垃圾回收自动回收不再使用的内存
4. 说明：
   1. 全局变量一般不会回收（关闭页面回收）；
   2. 一般情况下局部变量的值，不用了，会被自动回收掉

##### 拓展-JS垃圾回收机制-算法说明

​	堆栈空间分配区别：

1. 栈（操作系统）: 由操作系统自动分配释放函数的参数值、局部变量等，基本数据类型放到栈里面。
2. 堆（操作系统）: 一般由程序员分配释放，若程序员不释放，由垃圾回收机制回收。复杂数据类型放到堆里面。

​	两种常见的浏览器垃圾回收算法: **引用计数法** 和 **标记清除法**

- ###### 引用计数

​	IE浏览器采用的引用计数算法，定义“内存不再使用”，就是看一个对象是否指向它的引用，没有引用了就回收对象

​	算法：

1. 跟踪记录被引用的次数
2. 如果被引用了一次，那么就记录一次，多次引用会累加++
3. 如果减少一个引用就减1 --
4. 如果引用次数是0，则释放内存

![image-20241104154732483](C:\Users\12514\AppData\Roaming\Typora\typora-user-images\image-20241104154732483.png)

但它却存在一个致命的问题：**嵌套引用**（循环引用）
如果两个对象相互引用，尽管他们已不再使用，垃圾回收器不会进行回收，导致内存泄露

![image-20241104155540462](C:\Users\12514\AppData\Roaming\Typora\typora-user-images\image-20241104155540462.png)

因为他们的引用次数永远不会是0。这样的相互引用如果说很大量的存在就会导致大量的内存泄露

- 标记清除法

现代的浏览器已经不再使用引用计数算法了。

现代浏览器通用的大多是基于**标记清除算法**的某些改进算法，总体思想都是一致的。

​	**核心：**
1. 标记清除算法将“不再使用的对象”定义为“<u>无法达到的对象</u>”。
2. 就是从<u>根部</u>（在JS中就是全局对象）出发定时扫描内存中的对象。 凡是能<u>从根部到达</u>的对象，都是还<u>需要使用</u>的。
3. 那些<u>无法</u>由根部出发触及到的<u>对象被标记</u>为不再使用，稍后进行<u>回收</u>。

![image-20241104160755401](C:\Users\12514\AppData\Roaming\Typora\typora-user-images\image-20241104160755401.png)

![image-20241104160806907](C:\Users\12514\AppData\Roaming\Typora\typora-user-images\image-20241104160806907.png)

#### 闭包

**概念：**一个函数对周围状态的引用捆绑在一起，内层函数中访问到其他外层函数的作用域

简单理解：**<u>闭包=内层函数+外层函数的变量</u>**

先简单看个代码：

![image-20241104161255605](C:\Users\12514\AppData\Roaming\Typora\typora-user-images\image-20241104161255605.png)

闭包作用：封闭数据，提供操作，外部数据也可以访问数据内部的变量

闭包的基本格式：

比如：我们要做个统计函数调用次数，函数调用一次，就++

![image-20241104161411085](C:\Users\12514\AppData\Roaming\Typora\typora-user-images\image-20241104161411085.png)

但是，这个count 是个全局变量，很容易被修改→改进后，这样就实现了数据私有，无法直接修改count

#### 变量提升

变量提升是 JavaScript 中比较“奇怪”的现象，它允许在变量声明之前即被访问（仅存在于var声明变量）

注意：
1. 变量在未声明即被访问时会报语法错误
2. 变量在var声明之前即被访问，变量的值为 undefined
3. let/const 声明的变量不存在变量提升
4. 变量提升出现在相同作用域当中
5. 实际开发中推荐先声明再访问变量

![image-20241104163505190](C:\Users\12514\AppData\Roaming\Typora\typora-user-images\image-20241104163505190.png)

### 2.函数进阶

#### 2.1函数提升

函数提升与变量提升比较类似，是指函数在声明之前即可被调用

![image-20241106072418225](C:\Users\12514\AppData\Roaming\Typora\typora-user-images\image-20241106072418225.png)

总结：

1. 函数提升能够使函数的声明调用更灵活
2. 函数表达式不存在提升的现象
3. 函数提升出现在相同作用域当中

#### 2.2函数参数

##### 1.动态参数

arguments是函数内置的伪数组变量，它包含了调用函数时传入的所有实参

```js
//求和函数，计算所有参数的和
function sum(){
    //console.log(arguments)
    let s = 0
    for (let i = 0;i<arguments.length;i++){
        s+arguments[i]
    }
    console.log(s)
}
//调用求和函数
sum(5,10)//两个参数
sum(1,2,4)//三个参数
```

**总结：**

1. arguments是一个伪数组，只存在于函数中
2. arguments的作用时动态获取函数的实参
3. 可以通过for循环依次得到传递过来的实参



##### 2.剩余参数

1. …是语法符号，置于最末函数形参之前，用于获取**多余**的实参
2. 借助…获取的剩余参数，是个**真数组**

```js
function config(baseURL,…other){
    console.log(baseURL)//得到’http：//baidu.com‘
    console.log(other)//other 得到['get','json']
}
//调用函数
config('http://baidu.com','get','json')

```

> [!TIP]
>
> 开发中，提倡多使用**剩余参数**

##### **3.展开运算符**

展开运算符(...)，将一个数组进行展开

```js
const arr = [1,5,4,8,9]
console.log(...arr)//1,5,4,8,9
```

**说明**：

1. 不会修改原数组

<u>经典运用场景：求数组**最大值（最小值）**、**合并数组**等</u>

```js
const arr = [1,5,3,8,2]
//console.log(...arr)
console.log(Math.max(...arr))//8
console.log(Math.max(...arr))//1
```

```js
//合并数组
const arr1 = [1,2,3]
const arr2 = [4,5,6,2]
const arr3 = [...arr1,...arr2]
console.log(arr3)//[1,2,3,4,5,6,2]
```

**展开运算符or剩余参数**

剩余参数：函数参数使用，得到真数组

展开运算符：数组中使用，数组展开

```js
function getSum(...other){
    //other 得到[1,2,3]
    console.log(other)
}
getSum(1,2,3)
```

```js
const arr = [1,5,3,8,2]
console.log(...arr)//1,5,3,8,2
```

### 3.箭头函数（重要）

​	**目的：**引入箭头函数的目的是更简短的函数写法并且不绑定this，箭头函数的语法比函数表达式更简洁

​	**使用场景：**箭头函数更适合用于那些本来需要匿名函数的地方

#### 3.1基本语法

**语法1：基本写法**

```js
//普通函数
const fn = function(){
    console.log('我是普通函数')
}
fn()
```

```js
//箭头函数
const fn = () =>{
    console.log('我是箭头函数')
}
fn()
```

**语法2：只有一个参数可以省略小括号**

```js
//普通函数
const fn = function(x){
    return x+x
}
console.log(fn(1))//2

//箭头函数
const fn = x =>{
    return x+x
}
console.log(fn(1))//2
```

**语法3：如果函数体只有一行代码，可以写到一行，且无需写return直接返回值**

```js
更简洁的语法
const form = document.querySelector('form')
form.addEventListener('click',ev =>ev.preventDefault())
```

**语法4：加括号的函数体返回对象字面量表达式**

```js
const fn1 = uname => ({uname:uname})
console.log(fn1('pink老师')) //{uname:'pink老师'}
```

#### 3.2**<u>箭头函数参数</u>**

1. 普通函数有arguments动态参数
2. 箭头函数没有arguments动态参数，但是有 剩余参数...args

```js
const getSum =(...args) =>{
    let sum = 0
    for (let i =0;1<args.length;i++){
        sum +=args[i]
    }
    return sum //注意函数体有多行diamagnetic需要return
}
console.log(getSum(1,2,3))//6
```

#### 3.3箭头函数this

箭头函数不会创建自己的this，它只会从自己的作用域链的上一层沿用this。

```js
console.log(this)//此处是window
//箭头函数
const sayHi = ()=>{
    console.log(this)//箭头函数次数为window
}
btn.addEventListener('click',()=>{
    console.log(this)//当前this 指向window
})
```

```js
const user ={
    name:'小明'，
    //该箭头函数中的this为函数声明环境中this一致
    walk:()=>{
        console.log(this)//指向window 不是user
    }
}
user.walk()
```

```js
const user={
    name:'小明',
    sleep:function(){
        console.log(this)//指向user
        const fn = =>{
            console.log(this)//指向user，该箭头函数中的this与sleep一致
        }
        //调用箭头函数
        fn()
    }
}
user.sleep()
```

​	在开发中【使用箭头函数需考虑函数中的this的值】，事件回调函数使用箭头函数时，this为全局的window，因此DOM事件回调函数为了简便，还是不太推荐使用箭头函数。

```js
<script>
    //DOM节点
    const btn = document.qureySelector('.btn')
	//箭头函数 此时this指向了window
	btn.addEventListener('click',()=>{
        console.log(this)
    })
	//普通函数 此时this指向了DOM对象
	.btn.addEventListener('click',function(){
        console.log(this)
    })
</script>
```

### 4.解构赋值

​	结构赋值是一种快速为变量赋值的简介语法，本质上仍是为变量赋值

​	结构赋值分为：

1. 数组解构
2. 对象解构

#### 数组解构

​	**数组解构**:将数组的单元值快速批量赋值给一系列变量的简洁语法。

##### 1.基本语法：

1. 赋值运算符 = 左侧的[]用于批量声明变量，右侧数组的单元值将被赋值给左侧的变量
2. 变量的顺序对应数组单元值的位置依次进行赋值操作

```js
//普通的数组
const arr = [1,2,3]
//批量声明变量a b c
//同事将数组单元值1 2 3 依次赋值给变量a b c
const [a,b,c] = arr
console.log(a)//1
console.log(b)//2
console.log(c)//3

```

```js
//同事将数组单元值1，2，3 依次赋值给变量a b c 
const [a,b,c] = [1,2,3]
console.log(a)//1
console.log(b)//2
console.log(c)//3

//其中[a,b,c]为变量  [1,2,3]为单元值
```

1. **典型应用交互2个变量**

```js
let a =1
let b = 3; //这里必须要有分号
[b,a]=[a,b]
console.log(a)//3
console.log(b)//1
```

```js
<script>
    let arr =[2,6,4,3,5,1]
	//1.外层循环控制 趟数 循环4次  arr.length-1
	for(let i =0;i<arr.length-1;i++){
        //2.里层的循环 控制一趟交换次数 arr.length-i-1 次序
        for(let j = 0;j<arr.length-i-1;j++){
            //交换两个变量
            //arr[j] arr[j+1]
            if(arr[j]>arr[j+1]){
                [arr[j+1],arr[j]]=[arr[j],arr[j+1]]
            }
        }
    }
console.log(arr)
```

> [!WARNING]
>
> 注意：js前面必须加分号两种情况:

1. 立即执行函数

```js
(function t(){})();
//或者
;(function t(){})()2
```

​	2.数组解构

```js
//数组开头的，特别是前面有语句的一定要注意加分号
;[b,a] = [a,b]
```

```js
let a =1
let b = 3; //一定要加分号，面试题！！
[b,a]=[a,b]
console.log(a)//2
console.log(b)//3
```

##### 2.变量数量与单元值数量不等的两种情况

2.**变量多 单元值少的情况：**

![image-20241110094550719](C:\Users\12514\AppData\Roaming\Typora\typora-user-images\image-20241110094550719.png)

<u>变量的数量大于单元值数量时，多余的变量将被赋值为 undefined</u>

2.**变量少 单元值多的情况**

![image-20241110094826326](C:\Users\12514\AppData\Roaming\Typora\typora-user-images\image-20241110094826326.png)



##### 3.**利用剩余参数解决变量少 单元值多的情况**

```js
//利用剩余参数解决变量少 单元值多的情况
const [a,b,...tel] = ['小米','苹果','华为'，'格力','vivo']
console.log(a)//小米
console.log(b)//苹果
console.log(tel)//['华为'，'格力','vivo'] ,剩余参数返回的还是一个数组
```

剩余参数返回的还是一个数组



##### **4.防止有undefined传递单元值的情况，可以设置默认值：**

```js
const [a='手机',b='华为']=['小米']
console.log(a) //小米
console.log(b) //华为
```

允许初始变量的默认值，且只有单元值为undefined时默认值才会生效



##### **5.按需导入，忽略某些返回值：**

```js
const [a,,c,d] = ['小米','苹果','华为'，'格力',]
console.log(a)//小米
console.log(c)//华为
console.log(d)//格力
```

##### **6.支持多维数组的结构：**

```js
const [a,[b,c]]=['苹果',['小米','华为']]
console.log(a)//苹果
console.log(b)//小米
console.log(c)//华为
```

#### 对象解构

​	对象解构是将对象属性和方法快速批量赋值给一系列变量的简洁语法

##### 1.基本语法：

1. 赋值运算符= 左侧的 {} 用于批量声明变量，右侧对象的属性值将被赋值给左侧的变量
2. 对象属性的值将被赋值给属性名相同的变量
3. 注意解构的变量名不要和外面的变量名冲突，否则报错
4. 对象中找不到与变量名一致的属性时变量值为undefined

```js
<script>
    //普通对象
    const user = {
        name：'小明'，
        age：18
    }；
    //批量声明变量 name age
    //同时将数组单元值 小明  18 依次赋值给变量name age
    const {name，age} = user
    console.log(name) //小明
	console.log(age) //18
</script>
```

##### 2.给新的变量名赋值：

可以从一个对象中提取变量并同时修改变量名

![image-20241110101803763](C:\Users\12514\AppData\Roaming\Typora\typora-user-images\image-20241110101803763.png)

**数组对象解构**

```js
const pig = [
    {
        name:'佩奇'
        age:6
    }
]

const [{name,age}] =pig
console.log(name,age)
```

##### 3.多级对象解构

![image-20241110102145668](C:\Users\12514\AppData\Roaming\Typora\typora-user-images\image-20241110102145668.png)





#### 遍历数组forEach方法（重点）

- forEach()方法用于调用数组的每个元素，并将元素传递给回调函数
- 主要使用场景：**遍历数组每个元素**
- **语法：**

```js
被遍历的数组.forEach(function(当前数组元素，当前元素索引号)){
	//函数体
}
```

- 例如：

```js
const arr = ['pink','red','green']
arr.forEach(function(item,index){
    console.log('当前数组元素是：${item}') //依次打印数组每一个元素
    console.log('当前数组元素的索引时:${index}')//依次打印数组每一个元素的索引
```

![image-20241110103418651](C:\Users\12514\AppData\Roaming\Typora\typora-user-images\image-20241110103418651.png)

> [!CAUTION]
>
> 1. forEach主要是遍历数组。不会返回新数组，默认返回值是undefined。
> 2. 参数当前数组元素时必须要写的，索引号可选

#### 筛选数组filter方法（重点）

- filter()筛选数组
- 返回值：返回数组，包含了符合条件的所有元素。如果没有符合条件的元素则返回空数组
- **参数：**currentValue必须写，index可选
- 因为返回新数组，所以不会影响远数组

![image-20241110104223112](C:\Users\12514\AppData\Roaming\Typora\typora-user-images\image-20241110104223112.png)

### 5.深入对象

#### 5.1创建对象三种方式

**1.利用对象字面量创建对象**

```js
const o = {
    name:'佩奇'
}
```

**2.使用new Object创建对象**

```js
const O = new Object({name:'佩奇'})
console.log(o) //{name:'佩奇'}
```

#### 5.2构造函数

​	**构造函数：**是一种特殊的函数，主要用来初始化兑现

​	**使用场景：**常规的(...)语法允许创建一个对象。比如我们创建了一个佩奇的对象，继续创建乔治的对象还需要重新写一遍，此时可以通过构造函数来快速创建多个类似的对象。

![image-20241110110221275](C:\Users\12514\AppData\Roaming\Typora\typora-user-images\image-20241110110221275.png)



构造函数在技术上是常规函数。

不过有两个约定：

1. 它们的命名以大写字母开头。
2. 它们只能由‘new’操作符来执行

![image-20241110110416742](C:\Users\12514\AppData\Roaming\Typora\typora-user-images\image-20241110110416742.png)



- **构造函数语法：**大写字母开头的函数
- **创建构造函数：**

```js
//1.创建构造函数
function Pig(name){
    this.name = name
}
//2.new关键字调用函数
//new Pig('佩奇')
//接受创建的对象
const peppa = new Pig('佩奇')
console.log(peppa)//{name:'佩奇'}
```

**说明：**

1. 使用new关键字调用函数的行为被称为**<u>实例化</u>**
2. 实例化构造函数时没有参数可以省略()
3. 构造函数内部无需写return，返回值即为创建的新对象
4. 构造函数内部的return返回值无效，所以不要return
5. new Object()   new Date()也是实例化构造函数

**实例化执行过程**

说明：

1. 创建新对象
2. 构造函数this 指向新对象
3. 执行构造函数代码，修改this，添加新的属性
4. 返回新对象

#### 5.3实例成员&静态成员

**实例对象：**

​	通过构造函数创建的对象称为实例对象，实例对象种的属性和方法称为实例成员。

```js
//构造函数
function Person(){
//构造函数内部的this就是实例对象
//实例对象中动态添加属性
    this.name ='name'
//实例对象动态添加方法
    this.sayHi = function(){
        console.log('大家好~')
    }
}
//实例化，p1是实例对象
//p1 实际就是构造函数内部的 this
const p1 = new Person()
console.log(p1)
console.log(p1.name)//访问实例属性
p1.sayHi()//调用实例方法
```

**静态成员：**

​	构造函数的属性和方法称为静态成员

```js
//构造函数
function Person(name,age){
    //省略实例成员
}
//静态属性
Person.eyes = 2
person.arms = 2
//静态方法
Person.walk = function(){
    console.log('人都会走路')
    //this 指向person
    console.log(this.eyes)
}
```

**说明：**

1. 构造函数的属性和方法称为静态成员
2. 一般公共特征的属性或方法设置为静态成员
3. 静态成员方法种的this指向构造函数本身



### 6.内置构造函数 



​	在JavaScript中**最重要**的数据类型有6种:

​	**基本数据(简单数据)类型：**

- 字符串、数值、布尔、undefined、null

​	**引用类型：**

- 对象

​	但是，会有一些特殊的情况

```js
//普通字符串
const str = 'andy'
console.log(str.length) //4
```

​	其实字符串、数值、布尔、等基本类型也都有专门的构造函数，这些称为包装类型。

​	JS中几乎所有的数据都可以基于构造函数创建

​	**引用类型**

- Object、Array、RegExp、Date等

​	**包装类型**

- String、Number、Boolean等

#### 6.1Object

​	Object是内置的构造函数，用于创建普通对象

```js
//通过构造函数创建普通对象
const user = new object ({name:'小明，age：15'})
```

​	推荐使用字面量声明对象，而不是Object构造函数

**三种常用静态方法（静态方法就是只有构造函数Object可以调用的）**

```js
//想要获得对象里面的属性和值怎么做到的？
const o ={name:'佩奇'，age= 6}

for(let k in o){
    console.log(k)//属性 name age
    console.log(o[k])//值  佩奇 6
}
```

​	现在可以用新的方法了~

- 1.作用：Object.keys 静态方法获取对象中所有属性(键)
- 语法：

```js
const O ={name:'佩奇'，age:6}
//获取对象的所有键，并且返回是一个数组
const arr = Object.keys(o)
console.log(arr)//['name','age']
```

- 注意：返回的是一个数组



- 2.作用：Object.values静态方法获取对象中所有属性值
- 语法：

```js
const o ={name:'佩奇'，age:6}
//获得对象的所有值，并且返回是一个数组
const arr = Object.values(o)
console.log(arr)  //['佩奇'，6]
```

- 注意：返回的是一个数组



- 3.作用：Object.assig静态方法常用于对象拷贝
- 语法：

```js
//拷贝对象 把o拷贝obj
const o = {name:'佩奇'，age:6}
const obj = {}
Object.assign(obj,o)
console.log(obj)//{name:'佩奇'，age：6}
```

- 使用：经常使用的场景给对象添加属性

```js
//给o新增属性
const o = {name:'佩奇'，age:6}
Object.assign(o,{gender:'女'})
console.log(o)//{name:'佩奇'，age：6，gender:'女'}
```



#### 6.2Array

​	array是内置的构造函数，用于创建数组

```js
//构造函数创建数组
const arr = new Array(3,5)
console.log(arr)//[3,5]

//字面量方式创建数组
let list = ['html','css','javascript']

```

​	创建数组建议使用字面量，不用Array构造函数创建

**1.数组常见实例方法-核心方法**

![image-20241110123651385](C:\Users\12514\AppData\Roaming\Typora\typora-user-images\image-20241110123651385.png)

| 方法    | 作用     | 说明                                                         |
| ------- | -------- | ------------------------------------------------------------ |
| forEach | 遍历数组 | 不返回，用于不改变值，经常用于查找打印输出值                 |
| filter  | 过滤数组 | 筛选数组元素，并生成新数组                                   |
| map     | 迭代数组 | 返回新数组，新数组里面的元素是处理之后的值，经常用于处理数据 |
| reduce  | 累计器   | 返回函数立即处理的结果，经常用于求和等                       |

- 作用：reduce返回累计处理的结果，经常用于求和等
- **基本语法：**

```js
arr.reduce(function(累计值，当前元素[.索引号][,源数组]){},起始值)
```

- 参数：**起始值**可以省略，如果写就作为第一次累计的起始值
- 累计值参数：

1. 如果有起始值，则以起始值为准开始累计，累计值= 起始值
2. 如果没有起始值，则累计值以数组的第一个元素作为起始值开始累计
3. 后面每次遍历就会用后面的数组元素 累计到累计值里面（类似求和里面的sum）

- **使用场景：**

```js
const arr = [1,5,9]
const count = arr.reduce((prev,item)=>prev +item)
console.log(count)
```

**2.数组常见方法-其他方法**

**总结:**

1. 推荐使用字面量方式声明数组，而不是`Array`构造函数
2. 实例方法`forEach`用于遍历数组，替代`for`循环(重点)
3. 实例方法`filter`过滤数组单元值，生成新数组（重点）
4. 实例方法`map`迭代原数组，生成新数组（重点）
5. 实例方法`join`数组元素拼接为字符串，返回字符串（重点）
6. 实例方法`find`查找元素，返回符合测试条件的第一个数组元素值，如果没有符合条件的则返回undefined（重点）
7. 实例方法`every`检测数组所有元素是否都符合指定条件，如果**所有元素**都通过检测返回true，否则返回false（重点）
8. 实例方法`some`检测数组中的元素是否满足指定条件 **如果数组中有**元素慢速条件返回true，否则返回false。
9. 实例方法`concat`合并数组，返回生成新数组
10. 实例方法`sort`对源数组单元值排序
11. 实例方法`splice`删除或替换原数组单元
12. 实例方法`reverse`反转数组
13. 实例方法`findIndex`查找元素的索引值

#### 包装类型

在 JavaScript 中的字符串、数值、布尔具有对象的使用特征，如具有属性和方法，如下代码举例：

```html
<script>
    //字符产类型
    const str = 'hello world!'
	console.log(str.length)

	//数字类型
	const price = 12.34
    //保留两位小数
    price.toFixed(2) //12.34
</script>
```

之所以具有对象特征的原因是字符串、数值、布尔类型数据是JavaScript底层使用Object构造函数“包装”来的，被称为包装类型。

##### 6.3String

`String`是内置的构造函数，用于创建字符串

```html
<script>
	//使用构造函数创建字符串
    let str = new String('hello world');
    
    //字面量创建字符串
    let str2 = '你好，世界';
    
    //检测是否属于同一个构造函数
    console.log(str.constructor === str2.constructor);//true
    console.log(str instanceof String);//false
</script>
```



**1.常见实例方法**

​	**总结：**

1. 实例属性 `length` 用来获取字符串的度长(重点)
2. 实例方法 `split('分隔符')` 用来将字符串拆分成数组(重点)
3. 实例方法 `substring（需要截取的第一个字符的索引[,结束的索引号]）` 用于字符串截取(重点)
4. 实例方法 `startsWith(检测字符串[, 检测位置索引号])` 检测是否以某字符开头(重点)
5. 实例方法 `includes(搜索的字符串[, 检测位置索引号])` 判断一个字符串是否包含在另一个字符串中，根据情况返回 true 或 false(重点)
6. 实例方法 `toUpperCase` 用于将字母转换成大写
7. 实例方法 `toLowerCase` 用于将就转换成小写
8. 实例方法 `indexOf`  检测是否包含某字符
9. 实例方法 `endsWith` 检测是否以某字符结尾
10. 实例方法 `replace` 用于替换字符串，支持正则匹配
11. 实例方法 `match` 用于查找字符串，支持正则匹配

注意：String也可以当做普通函数使用，这时它的作用的是强制转换成字符串数据类型。

##### 6.4Number

​	`Number`是内置的构造函数，用于创建数值。

```html
<script>
	//使用构造函数创建数值
    let x = new Number('10')
    let y = new Number(5)
    
    //字面量创建数值
    let z = 20
</script>
```

**总结：**

1. 推荐使用字面量方式声明数值，而不是`Number`构造函数
2. 实例方法`toFixed`用于设置保留小数位的长度





### 7.编程思想

##### 面向过程

​	**面向过程**就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候再一个一个的依次调用就可以了。

举个例子：蛋炒饭

![image-20241111124744210](C:\Users\12514\AppData\Roaming\Typora\typora-user-images\image-20241111124744210.png)

##### 面向对象（oop）

​	**面向对象**是八十五分解成为一个个对象，然后由对象之间分工与合作。

举个例子：盖浇饭

![image-20241111124917143](C:\Users\12514\AppData\Roaming\Typora\typora-user-images\image-20241111124917143.png)

- 在面向对象程序开发思想中，每一个对象都是功能中心，具有明确分工。
- 面向对象编程具有灵活性、代码可复用性、容易维护和开发的有点，更适合多人合作的大型软件项目
- 面向对象特性：
  - 封装性
  - 继承性
  - 多态性




面向过程编程优缺点：

- **优点：**性能比面向对象高，适合跟硬件联系很紧密的东西，例如单片机就采用的面向过程编程
- **缺点：**没有面向对象易维护、易复用、易扩展

面向对象编程优缺点：

- **优点：**易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，是系统更加灵活、更加易于维护
- **缺点：**性能比面向过程低

### 8.构造函数

- 封装是面向对象思想中比较重要的一部分，js面向对象可以通过构造函数实现的封装。
- 同样的将变量和函数组合到了一起并能通过this实现数据的共享，所不同的是借助构造函数创建出来的实例对象之间是碧辟不要影响的

```js
function Star(uname,age){
    this.uname = uname
    this.age = age
    this.sing = function(){
        console.log('我会唱歌')
    }
}
//实例对象，获得了构造函数中对封装的所有逻辑
const ldh = new Star('刘德华',18)
const zxy = new Star('张学友',19)

console.log(1dh.sing === zxy.sing)//结果是false说明俩函数不一样
```

**总结：**

1. 构造函数体现了面向对象的封装性
2. 构造函数实例创建的对象彼此独立、互不影响

![image-20241111204701643](C:\Users\12514\AppData\Roaming\Typora\typora-user-images\image-20241111204701643.png)

### 9.原型对象

#### 9.1.原型

- 构造函数通过原型分配对象的函数是所有对象**所共享的**
- JavaScript规定，每一个构造函数都有一个prototype属性，指向另一个对象，所以我们也成为**<u>原型对象</u>**
- 这个对象可以挂载函数，对象实例化不会多次创建原型上函数，节约内存
- 我们可以把那些不变的方法，直接定义在prototype对象上，这样所有对象的实例就可以共享这些方法。
- 构造函数和原型对象中的this都指向实例化对象。

![image-20241111205800859](C:\Users\12514\AppData\Roaming\Typora\typora-user-images\image-20241111205800859.png)

##### 9.1.1原型-this指向

​	构造函数和原型对象中的this都指向实例化对象

```js
let that
function Person(name){
    this.name = name
    that = this
}
const o = new Person()
console.log(that === o) //true

```

```js
let that
function Person(name){
    this.name = name
}
Person.prototype.sing = function(){
    that.name = this
}
const o =new Person()
o.sing()
console.log(that === o) //true
```

#### 9.2 constructor属性

1. **在哪里？** 每个原型对象里面都有个constructor属性（constructor构造函数）
2. **作用：**该属性指向该原型对象的构造函数，简单理解，就是指向我的爸爸，我是有爸爸的孩子。

![image-20241111212539554](C:\Users\12514\AppData\Roaming\Typora\typora-user-images\image-20241111212539554.png)

**使用场景：**

​	如果有多个对象的方法，我们可以给原型对象采取对象形式赋值

​	但是这样就会覆盖构造函数原型对象原来的内容，这样修改后的原型对象constructor就不再指向当前构造函数了，此时，我们可以再修改后的原型对象中，添加一个constructor指向原来的构造函数。

```js
function Star (name){
    this.name = name
}
Star.prototype = {
    sing:function(){console.log('唱歌')},
    dance:function(){console.log('跳舞')}
}
console.log(Star.prototype.constructor)//指向Object
```

```js
function Star(name){
    this.name = name
}
Star.prototype ={
    //手动利用constructor指回Star构造函数
    constructor：Star，
    sing:function(){console.log('唱歌')},
	dance:function(){console.log('跳舞')}
}
console.log(Star.prototype.constructor)//指向Star
```

​	**构造函数**可以创建实例对象，构造函数还有一个原型对象，一些公共的属性或者方法放到这个原型对象身上

![image-20241111214918664](C:\Users\12514\AppData\Roaming\Typora\typora-user-images\image-20241111214918664.png)



#### 9.3对象原型

​	对象都会有一个属性—_proto_—指向构造函数prototype原型对象，之所以我们的对象可以使用构造函数prototype原型对象属性和方法，就是因为对象有—proto—原型的存在。

![image-20241111215446001](C:\Users\12514\AppData\Roaming\Typora\typora-user-images\image-20241111215446001.png)

> [!CAUTION]
>
> 1. —__proto__—是JS非标准属性
> 2. [[prototype]]和—__proto__—意义相同
> 3. 用来表明当前实例对象指向哪个原型对象prototype
> 4. —__proto__—对象原型里面也有constructor属性，**指向创建该实例对象的构造函数**



![image-20241111215849995](C:\Users\12514\AppData\Roaming\Typora\typora-user-images\image-20241111215849995.png)

![image-20241111215938819](C:\Users\12514\AppData\Roaming\Typora\typora-user-images\image-20241111215938819.png)

#### 9.4原型继承

​	继承是面向对象编程的另一个特征，通过继承进一步提升代码封装的程度，JavaScript中大多数是借助原型对象实现继承的特性。

​	龙生龙，凤生凤，老鼠的儿子会打洞描述的正是继承的含义

```js
function Man(){
    this.head = 1;
    this.eyes = 2;
    this.legs = 2;
    this.say = function(){},
    this.eat = function(){}
}
const pink = new Man()
```

```js
function Woman(){
    this.head = 1;
    this.eyes = 2;
    this.legs = 2; 
    this.say = function(){},
    this.eat = function(){},
    this.bady = function(){}
}
const red  = new Woman()
```

##### 	1.封装-抽取公共部分

​	把男人和女人公共的部分抽取出来放到人类里面

```js
//人类
const People = {
    head: 1,
    eyes: 2,
    legs: 3,
    say:function(){},
    eat:function(){}
}
//男人
function Man(){
    
}
//女人
function Woman(){
    this.bady = function(){}
}
```

##### 2.继承-让男人和女人能继承人类的一些属性和方法

- 把男人和女人公共的属性和方法抽取出来People
- 然后赋值给Man的原型对象，可以共享这些属性和方法
- 注意让constructor指回Man这个构造函数

```js
//人类 公共的属性和方法
const People ={
    head:1,
    eyes:2,
    legs:2,
    say:function(){},
    eat:function(){}
}
//男人
function Man(){
}
//把公共的属性和方法给原型了，这样就可以共享了
Man.prototype = People
//注意让原型里面的constructor从新增指回Man找自己的爸爸
Man.prototype.constructor = Man
const pink = new Man()
console.log(pink)
```

![image-20241113001356339](C:\Users\12514\AppData\Roaming\Typora\typora-user-images\image-20241113001356339.png)

##### 3.问题：如果我们给男人添加了一个吸烟的方法，发现女人自动也添加这个方法

![image-20241113001945049](C:\Users\12514\AppData\Roaming\Typora\typora-user-images\image-20241113001945049.png)

**原因：**男人和女人都同时使用了同一个对象，根据引用类型的特点，它们指向同i个对象，修改一个就会都影响

![image-20241113002223928](C:\Users\12514\AppData\Roaming\Typora\typora-user-images\image-20241113002223928.png)

##### 4.解决

需求：男人和女人不要使用同一个对象，但是不同对象里面包含相同的属性和方法

答案：构造函数

new每次都会创建一个新的对象

```js
function Star(){
    this.age = 18
    this.say = function(){}
}
const ldh = new Star()
const zxy = new Star()
console.log(ldh)
console.log(zxy)
console.log(ldh === zxy)//false每个实例对象都不一样
```

![image-20241113003259282](C:\Users\12514\AppData\Roaming\Typora\typora-user-images\image-20241113003259282.png)

##### 5.继承写法完善

```js
//人类 公共的属性和方法
function Person(){
    this.head = 1
    this.eyes = 2
    this.legs = 2
    this.say = function(){}
    this.eat = function(){}
}
console.log(new Person())//就是输出刚才的对象
```

![image-20241113003734387](C:\Users\12514\AppData\Roaming\Typora\typora-user-images\image-20241113003734387.png)

![image-20241113003833145](C:\Users\12514\AppData\Roaming\Typora\typora-user-images\image-20241113003833145.png)



**思路：**

​	真正做这个案例，思路应该是先考虑大的，后考虑小的

1. 人类共有的属性和方法有那些，然后做个构造函数，进行封装，一般公共属性写到构造函数内部，公共方法，挂载到构造函数原型身上
2. 男人继承人类的属性和方法，之后创建自己独有的属性和方法
3. 女人同理



#### 9.5原型链

​	基于原型对象的继承使得不同构造函数的原型对象关联在一起，并且这种关联的关系时一种链状的结构，我们将原型对象的链状结构关系称为原型链。

![image-20241113004410695](C:\Users\12514\AppData\Roaming\Typora\typora-user-images\image-20241113004410695.png)

**查找规则**

1. 当访问一个对象的属性（包括方法）时，首先查找这个对象自身有没有该属性。
2. 如果没有就查找它的原型（也就是-proto-指向的prototype原型对象）
3. 如果还没有就查找原型对象的原型（Object的原型对象）
4. 依次类推一直找到Object为止（null）
5. -proto-对象原型的意义就在于为对象成员查找机制提供一个方向，或者说一条路线
6. 可以使用instanceof运算符用于检测构造函数的prototype属性是否出现在某个实例对象的原型链上。



### 10.深浅拷贝

​	开发中经常需要复制一个对象，如果直接用赋值会有下面的问题：

```js
//一个pink对象
const pink = {
    name:'pink老师'，
    age:18
}
const red = pink
console.log(red)//{name:'pink老师'，age：18}
red.name = 'red老师'
console.log(red)//{name:’red老师‘，age:18}
//但是pink对象里面的name值也发生了变化
console.log(pink)//{name：'red老师'，age:18}
```

![image-20241117101906855](C:\Users\12514\AppData\Roaming\Typora\typora-user-images\image-20241117101906855.png)

#### 浅拷贝

​	浅拷贝和深拷贝都只针对引用类型

​	浅拷贝：拷贝的是地址

​	**常用方法：**

1. 拷贝对象：Object.assgin()/展开运算符{...obj}拷贝对象
2. 拷贝数组：Array.prototype.concat()或则[...arr]

```js
const obj = {
    uname:'pink'
}
const o = {...obj}
console.log(o)
o.uname='red' // {uname:'red'}
console.log(obj)//{uname:'pink'}
```

```js
//一个pink对象
const pink = {
    name:'pink老师'，
    age:18
}
const red = {}
Object.assign(red,pink)
console.log(red)//{name:'pink老师'，age：18}
red.name = 'red老师'
console.log(red)//{name:’red老师‘，age:18}
//不会影响pink对象
console.log(pink)//{name:'pink',age:18}
```

![image-20241117105418345](C:\Users\12514\AppData\Roaming\Typora\typora-user-images\image-20241117105418345.png)

如果是简单数据类型的拷贝值，引用数据类型拷贝的是地址（简单理解：如果是单层对象，没问题，如果有多层对象就有问题）

![image-20241117110451159](C:\Users\12514\AppData\Roaming\Typora\typora-user-images\image-20241117110451159.png)

#### 深拷贝

​	深拷贝：拷贝的是对象不是地址

**常见方法：**

1. 通过递归实现拷贝
2. lodash/cloneDeep
3. 通过JSON.stringify()时实现

##### 	1.通过递归实现深拷贝

​	函数递归：

如果一个函数在内部可以调用其本身，那么这个函数就是递归函数

- 简单理解：函数内部自己调用自己，这个函数就是递归函数
- 递归函数的作用和循环效果类似
- 由于递归很容易发生“栈溢出”错误（stack overflow），所以必须要加推出条件return

![image-20241117111603996](C:\Users\12514\AppData\Roaming\Typora\typora-user-images\image-20241117111603996.png)

```js
let num = 1
//fn就是递归函数
function fn(){
    console.log('我要打印6次')
    if(num>=6){
        return
    }
    num++
    fn()//函数内部调用函数自己
}
fn()
```

​	**利用递归函数实现setTimeout 模拟setInterval效果**

##### 2.js库lodash里面cloneDeep内部实现了深拷贝

```js
const obj ={
    uname:'pink',
    age:18,
    hobby:['篮球'，'足球']，
    family:{
    	baby:'小pink'
	}
}
//语法：_.cloneDeep(要被克隆的对象)
const o = _.cloneDeep(obj)
console.log(o)
o.family.bady= '老pink'
console.log(obj)
```

##### 3.通过JSON.stringify()实现

```js
const obj = {
    uname:'pink',
    age:18,
    hobby:['篮球'，'足球'],
    family:{
        baby:'小pink'
    }
}
const o = JSON.parse(JSON.stringify(obj))
console.log(o)
o.family.baby = '老pink'
console.log(obj)
```



### 11.异常处理

#### 	1.throw抛异常

​	异常处理是指预估代码执行过程中可能发生的错误，然后最大程度上避免错误的发生导致整个程序无法继续运行

```js
function counter(x,y){
    if(!x||!y){
        //throw '参数不能为空！'
        throw new Error('参数不能为空')
    }
    return x+y
}
counter()
```

**总结：**

1. throw抛出异常信息，程序也会终止执行
2. throw后面跟的是错误提示信息
3. Error对象配合throw使用，能够设置更详细的错误信息

#### 	2.try/catch捕获异常

​	可以通过try / catch 捕获错误信息（浏览器提供的错误信息）

```js
function foo(){
    try{
        //查找DOM节点
        const p = document.querySelector('.p')
        p.style.color = 'red'
    } catch (error){
        //try代码中执行有错误时，会执行catch代码段
        //查看错误信息
        console.log(error.message)
        //终止代码继续执行
        return
    }
    finally{
        alert('执行')
    }
    console.log('如果出现错误，我的语句不会执行')
}
foo()
```

**总结：**

1. try…catch用于捕获错误信息
2. 将预估可能发生的代码写在try代码段中
3. 如果try代码段出现错误后，会执行catch代码段，并截获到错误信息
4. finally不管是否有错误，都会执性

#### 	3.debugger

```js
const arr[1,3,5]
const newArr = arr.map((item,index) =>{
    debugger
    console.log(item)//当前元素
    console.log(index)//当前元素索引号
    return item + 10 //让当前元素 +10
})
console.log(newArr)//[11,13,15]
```

![image-20241117122017604](C:\Users\12514\AppData\Roaming\Typora\typora-user-images\image-20241117122017604.png)

### 12.处理this

#### 1.this指向

​	this是JavaScript最具'魅惑'的知识点，不同的应用场合this的取值可能会有意想不到的结果

​	**1.普通函数this指向**

​	普通函数的调用方式决定了this的值，即【谁调用的this 值指向谁】

```js
//普通函数
function sayHi(){
    console.log(this)
}
调用表达式
const sayHello = function(){
    console.log(this)
}
//函数的调用方式决定了this的值
sayHi()//window
window.sayHi()
```

```js
return user = {
    name:'小明',
    walk:function(){
        cosole.log(this)
    }
}
//动态为user添加方法
user.sayHi = sayHi
user.sayHello = sayHello
//函数调用方式，决定了this的值
user.sayHi()
user.sayHello()
```

```html
 <script>
     'user strict'    
     function fn(){        
        console.log(this)//undefined    
     	}
	fn()
</script>	
```

​	**2.箭头函数this指向**

​	箭头函数中的this与普通函数完全不同，也不受调用方式的影响，<u>**事实上箭头函数中并不存在this！**</u>

1. 箭头函数会默认帮我们绑定外层this的值，所以在箭头函数中this的值和外层this是一样的
2. 箭头函数中的this引用的就是最近作用域中的this
3. 向外层作用域中，一层一层找this，直到有this的定义

![image-20241117130216596](C:\Users\12514\AppData\Roaming\Typora\typora-user-images\image-20241117130216596.png)

​	**注意情况1：**

​	在开发中【使用箭头函数前需考虑函数中的this的值】，事件回调函数使用箭头函数时，this为全局的window因此DOM事件回调函数 如果里面需要DOM对象的this，则不推荐使用箭头函数

```js
//DOM 节点
const btn = document.querySelector('.btn')
//箭头函数 此时this指向了window
btn.addEventListener('click',()=>{
    console.log(this)
})
//普通函数 此时 this 指向了DOM对象
btn.addEventListener('click',function(){
    console.log(this)
})
```

​	**注意情况2：**

​	同样由于箭头函数this的原因，基于原型的面向对象也不推荐采用箭头函数

```js
function Person(){
}
//原型对象上添加了箭头函数
Person.prototype.walk =()=>{
    console.log('人都要走路…')
    console.log(this);window
}
const p1 = new Person()
p1.walk()
```

​	**总结：**

1. 函数内不存在this，沿用上一级的
2. 不适合
   1. 构造函数，原型函数，dom事件函数等等
3. 适用
   1. 需要使用上层this的地方
4. 使用正确的话，他会在很多地方带来方便

#### 2.改变this

​	JavaScript中还允许指定函数中的this的指向，有3个方法可以动态指定普通函数中的this指向

- call()
- apply()
- bind()

​	**1.call()-了解**

​	使用call方法调用函数，同时指定呗调用函数中this的值

- 语法

```js
fun.call(thisArg,arg1,arg2,…)
```

- thisArg：在fun函数运行时指定的this值
- arg1，arg2：传递的其他参数
- 返回值就是函数的返回值，因为它就是调用函数

```js
const obj = {
    name:'pink'
}
function fn(){
    console.log(this)//指向obj{name:'pink'}
}
```

```js
const obj={
    name:'pink'
}
function fn(x,y){
    console.log(this)//指向obj{name:'pink'}
    console.log(x+y)//传递过来的参数相加
}
fn.call(obj,1,2)
```

​	**2.apply()-理解**

​	使用apply方法调用函数，同时指定被调用函数中的this

- **语法**

  ```js
  fun.apply(thisArg,[argsArray])
  ```

  - thisArg:在fun函数运行时自定的this值
  - argsArray：传递的值，必须包含在**数组**里面
  - 返回值就是函数的返回值，因为它就是调用函数
  - 因此apply主要跟数组有关系，比如使用Math.max()求数组的最大值

  **求数组最大两个方法：**

```js
//求数组最大值
const arr =[3,5,2,9]
console.log(Math.max.apply(null,arr))//9 利用apply
console.log(Math.max(…arr))//9 利用展开运算符
```

​	**3.bind()-重点**

- bind()方法不会调用函数。但是能改变函数呢不this指向

- **语法**：

  ```js
  fun.bind(thisArg,arg1,arg2,…)
  ```

  - thisArg：在fun函数运行时指定的this值
  - arg1，arg2：传递的其他参数
  - 返回由指定的this值和初始化参数改造的原函数拷贝(新函数)
  - 因此当我们只是想改变this指向，并且不想调用这个函数的时候，可以使用bind，比如改变定时器内部的this指向

**call apply bind 总结**

- 相同点：
  - 都可以改变函数内部的this指向
- 区别点：
  - call和apply会调用函数，并且改变函数内部this指向
  - call和apply传递的参数不一样，call传递参数aru1，aru2…形式，apply必须数组形式[arg]
- 主要应用场景：
  - call调用函数并且可以传递参数
  - apply经常跟数组有关系，比如借助于数学对象实现数组最大值最小值
  - bind不调用函数，但是还想改变this指向，比如改变定时器内部this指向

### 13.性能优化

#### 1.防抖

- **防抖（debounce）**

  所谓防抖，就是指触发事件后在n 秒内函数只能执行一次，如果在n 秒内又触发了事件，则会重新计算函数执行时间

- **举个栗子：**

  北京买房政策：需要连续5年的社保，如果中间有一年断了社保，则需要从新开始计算

  比如，我2020年开始计算，连续交5年，也就是到2024年可以买房了，包含2020年

  但是我2024年断社保了，整年没交，则需要从2025年开始算第一年往后推5年… 也就是2029年才能买房…

- **开发使用场景- <u>搜索框防抖</u>**
  假设输入就可以发送请求，但是不能每次输入都去发送请求，输入比较快发送请求会比较多
  我们设定一个时间，假如300ms， 当输入第一个字符时候，300ms后发送请求，但是在200ms的时候又输入了一个字符，则需要再等300ms 后发送请求

**Lodash库 实现节流和防抖**

```js
const box = documen.querySelector('.box')
let i=1
function mouseMove(){
    box.innerHTML = i++
    //如果存在开销较大操作，大量数据处理，大量dom操作，可能会卡
}
box.addEventLinstener('mousemove',_.debounce(mouseMove,1000))
```

```js
const box = document.querySelector('.box')
let i = 1
function mouseMove(){
    box.innerHTML = i++
    //如果存在开销较大操作，大量数据处理，大量dom操作，可能会卡
}
box.addEventListener('mousemove',_.debounce(moveMove,))
```

#### 2.节流

- 节流（throttle）

所谓节流，就是指连续触发事件但是在n 秒中只执行一次函数

![image-20241118142958369](C:\Users\12514\AppData\Roaming\Typora\typora-user-images\image-20241118142958369.png)

- **开发使用场景**– 小米轮播图点击效果、鼠标移动、页面尺寸缩放resize、滚动条滚动就可以加节流
- 假如一张轮播图完成切换需要300ms， 不加节流效果，快速点击，则嗖嗖嗖的切换
- 加上节流效果， 不管快速点击多少次， 300ms时间内，只能切换一张图片。

